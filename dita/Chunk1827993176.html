---
layout: base.njk
title: ''
index: 'toc.html'
notices: 'resources/oasis-notices.html'
commit: 'e2324147e84f2f8efdf508ded7bed075e2d0a7e4'
repository: 'oasis-tcs/dita'
classes: ''
---

<nav class="toc" role="toc"><ul><li><a href="introduction/dita-release-overview.html">Introduction</a></li><li><a href="archSpec/base/dita-terminology.html">DITA terminology, notation, and conventions</a></li><li><a href="archSpec/base/introduction-to-dita.html">Overview of DITA</a></li><li><a href="archSpec/base/accessibility-and-translation.html">Accessibility and translation</a></li><li><a href="archSpec/base/dita-map-processing.html">DITA map processing</a></li><li><a href="archSpec/base/ditaaddressing.html">DITA addressing</a></li><li><a href="archSpec/base/behaviors.html">DITA processing</a><ul class="nav nav-list"><li><a href="archSpec/base/navigation.html#navigation">Navigation</a></li><li><a href="Chunk1503475370.html#Chunk1503475370">Indexes</a></li><li><a href="Chunk1384410096.html#Chunk1384410096">Content reference (conref)</a></li><li><a href="Chunk1128043901.html#Chunk1128043901">Conditional processing</a></li><li class="active"><a href="Chunk1827993176.html#Chunk1827993176">Branch filtering</a><ul class="nav nav-list"><li><a href="Chunk1827993176.html#branch-filter">Branch filtering</a></li></ul></li><li><a href="archSpec/base/sort-as-processing.html#sort-as-processing">Sorting</a></li><li><a href="archSpec/base/determining-effective-attribute-values.html#concept_afm_sz2_t3b">Determining effective attribute values</a></li></ul></li><li><a href="archSpec/base/configuration-specialization-and-constraints.html">Configuration and specialization </a></li><li><a href="langRef/langRef-base.html">Element reference</a></li><li><a href="conformance/conformance.html">Conformance</a></li><li><a href="acknowledgments/acknowledgments.html#r-acknowledgments">Acknowledgments</a></li><li><a href="non-normative/aggregated-RFC-2119-statements.html#aggregated-RFC-2119-statements">Aggregated RFC-2119 statements</a></li><li><a href="archSpec/base/coding-requirements.html#coding-practices">Coding practices for DITA grammar files</a></li><li><a href="non-normative/developing-constraint-and-expansion-modules.html#developing-constraint-and-expansion-modules">Constraint modules</a></li><li><a href="non-normative/expansion-modules.html#expansion-modules">Expansion modules</a></li><li><a href="non-normative/elementsMerged.html#elements">Element-by-element recommendations for translators</a></li><li><a href="non-normative/formatting-expectations.html#formatting-expectations">Formatting expectations</a></li><li><a href="non-normative/migrating-to-dita-2.0.html#migrating-to-dita-2.0">Migrating to DITA 2.0</a></li><li><a href="non-normative/basedoctypes.html#oasisdomains">OASIS grammar files</a></li><li><a href="non-normative/interoperability-considerations.html#nteroperability-considerations">Processing interoperability considerations</a></li><li><a href="non-normative/revision-history.html#revision-history">Revision history</a></li></ul></nav><main role="main" class=""><article role="article" aria-labelledby="ariaid-title1"><article class="nested0" aria-labelledby="ariaid-title1" id="Chunk1827993176"><h1 class="title topictitle1" id="ariaid-title1">Branch filtering</h1><nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="archSpec/base/behaviors.html" title="DITA processing is affected by a number of factors, including attributes that indicate the set of vocabulary and constraint modules on which a DITA document depends; navigation; linking; content reuse (using direct or indirect addressing); conditional processing; branch filtering; chunking; and more. In addition, translation of DITA content is expedited through the use of the dir, translate, and xml:lang attributes.">DITA processing</a></div></div></nav><article class="topic concept nested1" aria-labelledby="ariaid-title2" lang="en-us" id="branch-filter">
  <h2 class="title topictitle2" id="ariaid-title2">Branch filtering</h2>
  
  <div class="body conbody"><p class="shortdesc">The branch filtering mechanism enables map authors to set filtering conditions for
    specific branches of a map. This makes it possible for multiple conditional-processing profiles
    to be applied within a single publication.</p>
    <p class="p">Conditional processing profiles are most often used for an entire root map, with rules
      applied to all content in that root map. The branch filtering mechanism uses the
        <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element to apply rules from a single DITAVAL document
      against a subset of content.</p>
    <p class="p">The location of the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element determines the content to
      which filtering conditions are applied. The filtering conditions then are used to filter the
      map branch itself (that is, the map elements used to create the branch). In addition, it is
      used to filter local maps and topics that are referenced by that branch.</p>
    <p class="p">The <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element also provides the ability to process a single
      branch of content multiple times, applying unique conditions to each instance of the branch. </p>
    
  </div>
<article class="topic concept nested2" aria-labelledby="ariaid-title3" lang="en-us" id="branch-filter-overview">
    <h3 class="title topictitle3" id="ariaid-title3">Overview of branch filtering</h3>
    
    
    <div class="body conbody"><p class="shortdesc">Maps or map branches can be filtered by adding a
            <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element that specifies the DITAVAL document to use
        for that map or map branch.</p>
        <p class="p">The <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element is designed to manage conditional
            processing for the following use cases.</p>
        <ol class="ol">
            <li class="li">A map branch needs to be filtered using conditions that do
                not apply to the rest of the publication. <span class="ph example">For example, a
                    root map might contain content that is written for both novice and expert users.
                    However, the authors want to add a section that targets only novice users. Using
                    branch filtering, a map branch can be filtered so that it only includes content
                    germane to a novice audience, while the content of the rest of the map remains
                    appropriate for multiple audiences.</span></li>
            <li class="li">A map branch needs to be presented differently for different audiences. <span class="ph example">For example, a set of software documentation might contain
                    installation instructions that differ between operating systems. In that case,
                    the map branch with the installation instructions needs to be filtered multiple
                    times with distinct sets of conditions, while the rest of the map remains common
                    to all operating systems.</span></li>
        </ol>
        <p class="p">In addition to filtering, applications <dfn class="term RFC-2119">MAY</dfn> support
            flagging at the branch level based on the referenced DITAVAL documents.</p>
    </div>
</article><article class="topic concept nested2" aria-labelledby="ariaid-title4" id="branch_filtering_interactions">
    <h3 class="title topictitle3" id="ariaid-title4">How filtering rules interact</h3>
    
    <div class="body conbody"><p class="shortdesc">With branch filtering, it is possible to set include or exclude rules globally,
        within a map, and within an already filtered map branch. The general rule for conflicts is
        that once specified, "exclude" conditions are in effect for the entire map or
        branch.</p>
        <p class="p">Filtering rules often are specified globally in a conditional processing profile, outside
            of the content. When global conditions set a property value to "exclude", that setting
            overrides any other settings for the same property that are specified at a branch level.
            Global conditions that set a conditional property to "include" or "flag" do not override
            branch-level conditions that set the same property to "exclude".</p>
        <p class="p">Using <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements, it is possible to specify one set of
            conditions for a branch and another set of conditions for a subset of the branch. As
            with global conditions, properties set to "exclude" for a map branch override any other
            settings for the same property specified for a subset of the branch. Branch conditions
            that set a conditional property to "include" or "flag" do not override conditions on a
            subset of the branch that explicitly set the same property to "exclude".</p>
    </div>
</article><article class="topic concept nested2" aria-labelledby="ariaid-title5" lang="en-us" id="branch-filter-single-set">
    <h3 class="title topictitle3" id="ariaid-title5">Branch filtering: Single referenced DITAVAL document for a branch</h3>
    
    
    <div class="body conbody"><p class="shortdesc">Using a single <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element as a child of a map or map
        branch indicates that the map or map branch is filtered using the rules specified in the
        referenced DITAVAL document.</p>
        
        <p class="p">The following rules outline how the filtering conditions that are
            specified in DITAVAL document are applied:</p>
        <dl class="dl">
            
                <dt class="dt dlterm"><code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element as a direct child of a map</dt>
                <dd class="dd">The filtering conditions are applied to the entire map.</dd>
            
            
                <dt class="dt dlterm"><code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element within a map branch</dt>
                <dd class="dd">The filtering conditions are used to process the entire branch, including the
                    parent element that contains the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element.
                </dd>
            
            
                <dt class="dt dlterm"><code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element within a
                        <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> reference to a local map</dt>
                <dd class="dd">The filtering conditions are applied to the submap.</dd>
            
            
                <dt class="dt dlterm"><code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element within a
                        <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> reference to peer map</dt>
                <dd class="dd">The reference conditions are <strong class="ph b">not</strong> applied to the peer map.</dd>
            
        </dl>
    </div>
</article><article class="topic concept nested2" aria-labelledby="ariaid-title6" lang="en-us" id="branch-filter-multiple-sets">
    <h3 class="title topictitle3" id="ariaid-title6">Branch filtering: Multiple referenced DITAVAL documents for a branch</h3>
    
    
    <div class="body conbody"><p class="shortdesc">Using multiple <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements as the children of a map
        or map branch indicates that the map or map branch will be independently filtered using the
        rules that are specified in each referenced DITAVAL document.</p>
        <p class="p">When multiple <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements occur as children of the same
            element, the rules in the referenced DITAVAL documents are processed independently. This
            effectively requires a processor to maintain one copy of the branch for each
                <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>, so that each copy can be filtered using
            different conditions.</p>
        <div class="note note note_note non-normative"><span class="note__title">Note<span class="non-normative-label"> (non-normative)</span>:</span> <div class="note__body">In most cases, it is possible to create a valid, fully-resolved view of
            a map with branches copied to reflect the different <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>
            conditions. However, this might not be the case when multiple
                <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements occur as direct children of a root map.
            In this case, it is possible that the map could be filtered in a manner that results in
            two or more distinct versions of the <code class="keyword markupname xmlelement">&lt;title&gt;</code> or metadata. How
            this is handled is processor dependent. <span class="ph example">For example, when a
                root map has three <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements as children of
                    <code class="keyword markupname xmlelement">&lt;map&gt;</code>, a conversion to EPUB could produce an EPUB with
                three versions of the content, or it could produce three distinct EPUB
                documents.</span></div></div>
        <p class="p">When a processor maintains multiple copies of a branch for different condition sets, it
            has to manage situations where a single resource with a single key name results in two
            distinct resources. Key names must be modified in order to allow references to a
            specific filtered copy of the resource; without renaming, key references could only be
            used to refer to a single filtered copy of the resource, chosen by the processor. See
                <a class="xref" href="Chunk1827993176.html#resource-names" title="When map branches are cloned by a processor in order to support multiple condition sets, processors must manage conflicting resource and key names. The DITAVALref domain includes metadata elements that authors can use to specify how resource and key names are renamed.">Branch filtering: Impact on resource and key names</a> for details on how to manage
            resource names and key names.</p>
    </div>
</article><article class="topic concept nested2" aria-labelledby="ariaid-title7" lang="en-us" id="resource-names">
    <h3 class="title topictitle3" id="ariaid-title7">Branch filtering: Impact on resource and key names</h3>
    
    
    <div class="body conbody"><p class="shortdesc">When map branches are cloned by a processor in order to support multiple condition
        sets, processors must manage conflicting resource and key names. The DITAVALref domain
        includes metadata elements that authors can use to specify how resource and key names are
        renamed.</p>
        <div class="note note note_note non-normative"><span class="note__title">Note<span class="non-normative-label"> (non-normative)</span>:</span> <div class="note__body">While the processing controls that are described here are intended primarily for use
            with map branches that specify multiple condition sets, they also can be used with map
            branches that include only a single <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element.</div></div>
        <p class="p">When a map branch uses multiple condition sets, processors create multiple effective
            copies of the branch to support the different conditions. This results in potential
            conflicts for resource names, key names, and key scopes. Metadata elements inside of the
                <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element are available to provide control over
            these values, so that keys, key scopes, and URIs can be individually referenced within a
            branch.</p>
        <p class="p">For example, the following map branch references two DITAVAL documents:</p>
        <pre class="pre codeblock"><code>&lt;topicref href="productFeatures.dita" keys="features" keyscope="prodFeatures"&gt;
  &lt;ditavalref href="novice.ditaval"/&gt;
  &lt;ditavalref href="admin.ditaval"/&gt;
  &lt;topicref href="newFeature.dita" keys="newThing"/&gt;
&lt;/topicref&gt;</code></pre>
        <p class="p">In this case, the processor has two effective copies of
                <span class="ph filepath">productFeatures.dita</span> and <span class="ph filepath">newFeature.dita</span>.
            One copy of each topic is filtered using the conditions specified in
                <span class="ph filepath">novice.ditaval</span>, and the other copy is filtered using the
            conditions specified in <span class="ph filepath">admin.ditaval</span>.</p>
        <p class="p">If an author has referenced a topic using <code class="ph codeph">keyref="features"</code> or
                <code class="ph codeph">keyref="prodFeatures.features"</code>, a processor cannot distinguish
            which filtered copy is the intended target. The metadata elements in the DITAVALref
            domain provide a way to control this scenario.</p>
    </div>
<article class="topic concept nested3" aria-labelledby="ariaid-title8" id="branch_filtering_metadata_elements">
    <h4 class="title topictitle4" id="ariaid-title8">Using metadata elements in the DITAVAL reference domain</h4>
    
    <div class="body conbody"><p class="shortdesc">Metadata within the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element makes it possible to
        control changes to resource names and key scope names, so that each distinct filtered copy
        can be referenced in a predictable manner.</p>
        <p class="p">The DITAVALref domain defines four elements to control URI and key scope values within
            filtered map branches.</p>
        <dl class="dl">
            
                <dt class="dt dlterm"><code class="keyword markupname xmlelement">&lt;dvrResourcePrefix&gt;</code></dt>
                <dd class="dd"><span class="ph">The <code class="keyword markupname xmlelement">&lt;dvrResourcePrefix&gt;</code> element specifies the prefix to use when constructing the effective file names or resource IDs of the resources that are referenced from within the map branch that is implied by the ancestor <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element.</span> This enables a map
                    author to specify a prefix that is added to the start of resource names for each
                    resource in the branch.</dd>
            
            
                <dt class="dt dlterm"><code class="keyword markupname xmlelement">&lt;dvrResourceSuffix&gt;</code></dt>
                <dd class="dd"><span class="ph">The <code class="keyword markupname xmlelement">&lt;dvrResourceSuffix&gt;</code> element specifies the prefix to use when constructing the effective file names or resource IDs of the resources that are referenced from within the map branch that is implied by the ancestor <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element.</span> This enables a map
                    author to specify a suffix that is added to the end of resource names (before
                    any extension) for each resource in the branch.</dd>
            
            
                <dt class="dt dlterm"><code class="keyword markupname xmlelement">&lt;dvrKeyscopePrefix&gt;</code></dt>
                <dd class="dd"><span class="ph">The <code class="keyword markupname xmlelement">&lt;dvrKeyscopePrefix&gt;</code> element specifies the prefix to use when constructing the effective key scope names for the map branch that is implied by the ancestor <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element.</span> This enables a map
                    author to specify a prefix that is added to the start of key scope names for
                    each key scope in the branch. If no key scope is specified for the branch, this
                    can be used to establish a new key scope, optionally combined with a value
                    specified in <code class="keyword markupname xmlelement">&lt;dvrKeyscopeSuffix&gt;</code>.</dd>
            
            
                <dt class="dt dlterm"><code class="keyword markupname xmlelement">&lt;dvrKeyscopeSuffix&gt;</code></dt>
                <dd class="dd"><span class="ph">The <code class="keyword markupname xmlelement">&lt;dvrKeyscopeSuffix&gt;</code> element specifies the suffix to use when constructing the effective key scope names for the map branch that is implied by the ancestor <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element.</span> This enables a map
                    author to specify a suffix that is added to the end of key scope names for each
                    key scope in the branch.</dd>
            
        </dl>
        <p class="p">For example, the previous code sample can be modified as follows to create predictable
            resource names and key scopes for the copy of the branch that is filtered using the
            conditions that are specified in <span class="ph filepath">admin.ditaval</span>.</p>
        <pre class="pre codeblock"><code>&lt;topicref href="productFeatures.dita" keys="features" keyscope="prodFeatures"&gt;
  &lt;ditavalref href="novice.ditaval"/&gt;
  &lt;ditavalref href="admin.ditaval"&gt;
    &lt;ditavalmeta&gt;
      &lt;dvrResourcePrefix&gt;admin-&lt;/dvrResourcePrefix&gt;
      &lt;dvrKeyscopePrefix&gt;adminscope-&lt;/dvrKeyscopePrefix&gt;
    &lt;/ditavalmeta&gt;
  &lt;/ditavalref&gt;
  &lt;topicref href="newFeature.dita" keys="newThing"/&gt;
&lt;/topicref&gt;</code></pre>
        <p class="p">The novice branch does not use any renaming, which allows it to be treated as the default
            copy of the branch. As a result, when the topics are filtered using the conditions that
            are specified in <span class="ph filepath">novice.ditaval</span>, the resource names and key names
            are unmodified, so that references to the original resource name and key name will
            resolve to topics in the novice copy of the branch. This has the following effect on
            topics that are filtered using the conditions specified in
                <span class="ph filepath">admin.ditaval</span>:</p>
        <ul class="ul" id="branch_filtering_metadata_elements__ul_gyv_2km_ctb">
            <li class="li">The prefix <code class="ph codeph">admin-</code> is added to the beginning of each resource name
                in the admin branch.<ul class="ul" id="branch_filtering_metadata_elements__ul_hyv_2km_ctb">
                    <li class="li">The resource <span class="ph filepath">productFeatures.dita</span> becomes
                            <span class="ph filepath">admin-productFeatures.dita</span></li>
                    <li class="li">The resource <span class="ph filepath">newFeature.dita</span> becomes
                            <span class="ph filepath">admin-newFeature.dita</span></li>
                </ul></li>
            <li class="li">The prefix <code class="ph codeph">adminscope-</code> is added to the existing key scope
                    "prodFeatures".<ul class="ul" id="branch_filtering_metadata_elements__ul_iyv_2km_ctb">
                    <li class="li">The attribute value
                            <code class="ph codeph">keyref="adminscope-prodFeatures.features"</code> refers
                        explicitly to the admin copy of
                        <span class="ph filepath">productFeatures.dita</span></li>
                    <li class="li">The attribute <code class="ph codeph">keyref="adminscope-prodFeatures.newThing"</code>
                        refers explicitly to the admin copy of
                        <span class="ph filepath">newFeature.dita</span></li>
                </ul></li>
        </ul>
        <div class="note note note_note non-normative"><span class="note__title">Note<span class="non-normative-label"> (non-normative)</span>:</span> <div class="note__body">In general, the best way to reference a topic that will be
            modified based on branch filtering is to use a key rather than a URI. Key scopes and key
            names (including those modified based on the elements above) must be calculated by
            processors before other processing. This means that in the example above, a key
            reference to <code class="ph codeph">adminscope-prodFeatures.features</code> will always refer
            explicitly to the instance of <span class="ph filepath">productFeatures.dita</span> filtered against
            the conditions in <span class="ph filepath">admin.ditaval</span>, regardless of whether a processor
            has performed the filtering yet. References that use the URI
                <span class="ph filepath">productFeatures.dita</span> or
                <span class="ph filepath">admin-productFeatures.dita</span> could resolve differently (or fail
            to resolve), as discussed in <a class="xref" href="Chunk1827993176.html#branch-filtering-implications-of-processing-order" title="The branch filtering mechanism can result in changes to the global key space for a root map. As a result, processors are required to evaluate branch filtering in order to construct the key space.">Branch filtering: Implications of processing order</a>.</div></div>
    </div>
</article><article class="topic concept nested3" aria-labelledby="ariaid-title9" id="branch_filtering_renaming_multiple_times">
    <h4 class="title topictitle4" id="ariaid-title9">Renaming based on multiple <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements</h4>
    
    <div class="body conbody"><p class="shortdesc">It is possible for a branch with <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> already in
        effect to specify an additional <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>, where each
            <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> includes renaming metadata.</p>
        <p class="p">When renaming, metadata on the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> nested more deeply
            within the branch appears closer to the original resource or key name. For example:</p>
        <pre class="pre codeblock"><code>&lt;topicref href="branchParent.dita"&gt;
  &lt;ditavalref href="parent.ditaval"&gt;
    &lt;ditavalmeta&gt;
      &lt;dvrResourcePrefix&gt;parentPrefix-&lt;/dvrResourcePrefix&gt;
    &lt;/ditavalmeta&gt;
  &lt;/ditavalref&gt;
  &lt;!-- additional topics or layers of nesting --&gt;
  &lt;topicref href="branchChild.dita"&gt;
    &lt;ditavalref href="child.ditaval"&gt;
      &lt;ditavalmeta&gt;
        &lt;dvrResourcePrefix&gt;childPrefix-&lt;/dvrResourcePrefix&gt;
      &lt;/ditavalmeta&gt;
    &lt;/ditavalref&gt;
  &lt;/topicref&gt;
&lt;/topicref&gt;</code></pre>
        <p class="p">In this situation, the resource <span class="ph filepath">branchChild.dita</span> is given a prefix
            based on both the reference to <span class="ph filepath">parent.ditaval</span> and the reference to
                <span class="ph filepath">child.ditaval</span>. The value <span class="keyword">childPrefix-</span> is
            specified in the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> that is nested more deeply within
            the branch, so it appears closer to the original resource name. The resource
                <span class="ph filepath">branchChild.dita</span> would result in
                <span class="ph filepath">parentPrefix-childPrefix-branchChild.dita</span>. Suffixes (if
            specified) would be added in a similar manner, resulting in a name like
                <span class="ph filepath">branchChild-childSuffix-parentSuffix.dita</span>. Note that the
            hyphens are part of the specified prefix; they are not added automatically.</p>
    </div>
</article><article class="topic concept nested3" aria-labelledby="ariaid-title10" id="branch_filtering_handling_conflicts">
    <h4 class="title topictitle4" id="ariaid-title10">Handling resource name conflicts caused by branch filtering</h4>
    
    <div class="body conbody"><p class="shortdesc">It is possible to construct a root map where the branch filtering mechanism results
        in resource name conflicts.</p>
        <div class="div errorcondition">
            <p class="p"><span class="error-statement" id="branch_filtering_handling_conflicts__d2371e638" data-id=""></span>It is an error if <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>-driven branch cloning results
                in multiple copies of a topic that have the same resolved name. <span class="error-statement" id="branch_filtering_handling_conflicts__d2371t642" data-id=""></span>Processors <dfn class="term RFC-2119">SHOULD</dfn> report an error in such cases. Processors
                    <dfn class="term RFC-2119">MAY</dfn> recover by using an alternate naming
                scheme for the conflicting topics.</p>
            <p class="p">In rare cases, a single topic might appear in different branches that set different
                conditions, yet still produce the same result. For example, a topic might appear in
                both the admin and novice copies of a branch but not contain content that is
                tailored to either audience; in that case, the filtered copies would match. <span class="error-statement" id="branch_filtering_handling_conflicts__d2371t651" data-id=""></span>A
                processor <dfn class="term RFC-2119">MAY</dfn> consider this form of equivalence
                when determining if two references to the same resource should be reported as an
                error.</p>
        </div>
    </div>
</article></article><article class="topic concept nested2" aria-labelledby="ariaid-title11" lang="en-us" id="branch-filtering-implications-of-processing-order">
 <h3 class="title topictitle3" id="ariaid-title11">Branch filtering: Implications of processing order</h3>
 
 <div class="body conbody"><p class="shortdesc">The branch filtering mechanism can result in changes to the global key space for a root
    map. As a result, processors are required to evaluate branch filtering in order to construct the
    key space.</p>
    <p class="p">The full effects of the branch filtering process <dfn class="term RFC-2119">MUST</dfn> be
      calculated by processors before they construct the effective map and key scope structure. This
      requirement comes from the fact that the branch filtering process can result in new or renamed
      keys, key scopes, or URIs that make up the key space.</p>
    
    <div class="note note note_note non-normative"><span class="note__title">Note<span class="non-normative-label"> (non-normative)</span>:</span> <div class="note__body">The <code class="keyword markupname xmlatt">@keyref</code> attribute and related attributes are explicitly disallowed on
        <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>. This prevents any confusion resulting from a
        <code class="keyword markupname xmlatt">@keyref</code> that resolves to additional key- or resource-renaming
      metadata.</div></div>
  <p class="p">In general, the DITA specification refrains from mandating a processing order; thus publication
      results can vary slightly depending on the order in which processes are run. With branch
      filtering, processors are not required to apply filter conditions specified outside of the map
      and filter conditions specified with <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> at the same time in a
      publishing process.</p>
  <p class="p">For example, a processor might use the following processing order:</p>
    <ol class="ol">
      <li class="li">Apply externally-specified filter conditions to maps</li>
      <li class="li">Apply filtering  based on <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements</li>
    </ol>
    <p class="p">Because externally-specified "exclude" conditions always take precedence over
      branch-specific conditions, content excluded based on external conditions will always be
      removed, regardless of the order in which processors evaluate conditions.</p>
    
  <p class="p">Processors should consider the following points when determining a processing order:</p>
    <ul class="ul">
      
      <li class="li">If links are generated based on the map hierarchy, those links should be created using the
        renamed keys and URIs that result from evaluating the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>
        filter conditions, to ensure that the links are consistent within the modified branches. For
        example, sequential links based on a map hierarchy should remain within the appropriate
        modified branch.</li>
      <li class="li">If URI-based content references are resolved in topics before the
          <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> filtering conditions are evaluated, content that
        applies to multiple audiences can be brought in and (later in the process) selectively
        filtered by branch. <span class="ph example">For example, if a set of installation steps is
          pulled in with conref (from outside the branch), it might contain information that is
          later filtered by platform based on <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>. This results in
          copies of the steps that are specific to each operating system. If conref is processed
          after the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>, content might be pulled in that has not
          been appropriately filtered for the new context.</span></li>
      <li class="li">The same scenario applies to conref values that push content into the branch.<ul class="ul">
          <li class="li">Pushing content into a branch before resolving the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>
            conditions allows content for multiple conditions to be pushed and then filtered by
            branch based on the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> conditions.</li>
          <li class="li">If the branch using <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> pushes content elsewhere,
            resolving <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> first could result in multiple copies of
            the content to be pushed (one for each branch), resulting in multiple potentially
            conflicting copies pushed to the new destination.</li>
        </ul>
      </li>
    </ul>
 </div>
</article><article class="topic concept nested2 non-normative" aria-labelledby="ariaid-title12" lang="en-us" id="examples-of-branch-filter">
    <h3 class="title topictitle3" id="ariaid-title12">Examples of branch filtering</h3>
    <div class="body"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">The branch filtering examples illustrate the processing expectations
        for various scenarios that involve <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements. Processing
        examples use either before and after sample markup or expanded syntax that shows the
        equivalent markup without the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements.</p></div>
<article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title13" lang="en-us" id="example-single-ditavalref">
  <h4 class="title topictitle4" id="ariaid-title13">Example: Single <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> on a branch</h4>
  
  <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">In this scenario, a single <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element is used to
    supply filtering conditions for a branch.</p>
    <div class="example non-normative" id="example-single-ditavalref__ditaval-specific-to-branch"><h5 class="title sectiontitle">Example</h5><p class="non-normative-label">This section is non-normative.</p>
      <p class="p">Consider the following DITA map and the DITAVAL document that is referenced from the
          <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element:</p>
      <figure class="fig fignone" id="example-single-ditavalref__fig_bcv_nhj_ln"><figcaption><span class="fig--title-label">Example 1. </span><span class="ph filepath">input.ditamap:</span></figcaption>
        
        <pre class="pre codeblock"><code>
&lt;map&gt;
  &lt;topicref href="intro.dita"/&gt;
  &lt;topicref href="install.dita"&gt;
    &lt;ditavalref href="novice.ditaval"/&gt;
    &lt;topicref href="do-stuff.dita"/&gt;
    &lt;topicref href="advanced-stuff.dita" audience="admin"/&gt;
    &lt;!-- more topics --&gt;
  &lt;/topicref&gt;
  &lt;!-- Several chapters worth of other material --&gt;
&lt;/map&gt;
</code></pre>
      </figure>
      <figure class="fig fignone" id="example-single-ditavalref__fig_b3v_nhj_ln"><figcaption><span class="fig--title-label">Example 2. </span>Contents of <span class="ph filepath">novice.ditaval</span></figcaption>
        
        <pre class="pre codeblock"><code>&lt;val&gt;
  &lt;prop att="audience" val="novice" action="include"/&gt;
  &lt;prop att="audience" val="admin" action="exclude"/&gt;
&lt;/val&gt;</code></pre>
      </figure>
      <p class="p">When this content is published, the following processing occurs:</p>
      <ul class="ul">
        <li class="li">The first topic (<span class="ph filepath">intro.dita</span>) does not use any of the conditions
          that are specified in <span class="ph filepath">novice.ditaval</span>. It is published normally,
          potentially using other DITAVAL conditions that are specified externally.</li>
        <li class="li">The second topic (<span class="ph filepath">install.dita</span>) is filtered using any external
          conditions as well as the conditions that are specified in
            <span class="ph filepath">novice.ditaval</span>.</li>
        <li class="li">The third topic (<span class="ph filepath">do-stuff.dita</span>) is filtered using any external
          conditions as well as the conditions that are specified in
            <span class="ph filepath">novice.ditaval</span>.</li>
        <li class="li">The fourth topic (<span class="ph filepath">advanced-stuff.dita</span>) is removed from the map
          entirely, because it is filtered out with the conditions that are specified for the
          branch.</li>
      </ul>
      <p class="p">In this example, no resources are renamed based on the
          <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> processing.</p>
      <div class="note note note_note non-normative"><span class="note__title">Note<span class="non-normative-label"> (non-normative)</span>:</span> <div class="note__body">In cases where the original resource names map directly to names or anchors in a
        deliverable, the absence of renaming ensures that external links to those topics are stable
        regardless of whether a DITAVAL document is used.</div></div>
    </div>
  </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title14" lang="en-us" id="example-multiple-ditavalref">
  <h4 class="title topictitle4" id="ariaid-title14">Example: Multiple <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements on a branch</h4>
  
  <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">In this scenario, multiple <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements are used on a
    single map branch to create multiple distinct copies of the branch.</p>
    <div class="example non-normative" id="example-multiple-ditavalref__mutltiple-ditavalref-create-multiple-branches"><h5 class="title sectiontitle">Example</h5><p class="non-normative-label">This section is non-normative.</p>
      <p class="p">Consider the following DITA map that contains a branch with three peer
          <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements. Because topics in the branch are filtered in
        three different ways, processors are effectively required to handle three copies of the
        entire branch. Sub-elements within the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements are used
        to control how new resource names are constructed for two copies of the branch; one copy
        (based on the conditions in <span class="ph filepath">win.ditaval</span>) is left with the original file
        names.</p>
      <figure class="fig fignone" id="example-multiple-ditavalref__fig_gmm_phj_ln"><figcaption><span class="fig--title-label">Example 3. </span><span class="ph filepath">input.ditamap</span></figcaption>
        
        <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;topicref href="intro.dita"/&gt;
  <strong class="ph b">&lt;!-- Begining of installing branch --&gt;</strong>
  &lt;topicref href="install.dita"&gt;
    &lt;ditavalref href="win.ditaval"/&gt;
    &lt;ditavalref href="mac.ditaval"&gt;
      &lt;ditavalmeta&gt;
        &lt;dvrResourceSuffix&gt;-apple&lt;/dvrResourceSuffix&gt;
      &lt;/ditavalmeta&gt;
    &lt;/ditavalref&gt;
    &lt;ditavalref href="linux.ditaval"&gt;
      &lt;ditavalmeta&gt;
        &lt;dvrResourceSuffix&gt;-linux&lt;/dvrResourceSuffix&gt;
      &lt;/ditavalmeta&gt;
    &lt;/ditavalref&gt;
    &lt;topicref href="do-stuff.dita"&gt;
    &lt;!-- more topics and nested branches --&gt;
      &lt;topicref href="mac-specific-stuff.dita" platform="mac"/&gt;
    &lt;/topicref&gt;
    <strong class="ph b">&lt;!-- End of installing branch --&gt;</strong>
    &lt;topicref href="cleanup.dita"/&gt;
  &lt;/topicref&gt;
&lt;/map&gt;</code></pre>
      </figure>
      <figure class="fig fignone" id="example-multiple-ditavalref__fig_fsm_phj_ln"><figcaption><span class="fig--title-label">Example 4. </span>Contents of <span class="ph filepath">win.ditaval</span></figcaption>
        
        <pre class="pre codeblock"><code>&lt;val&gt;
  &lt;prop att="platform" val="win" action="include"/&gt;
  &lt;prop att="platform" action="exclude"/&gt;
&lt;/val&gt;</code></pre>
      </figure>
      <figure class="fig fignone" id="example-multiple-ditavalref__fig_dym_phj_ln"><figcaption><span class="fig--title-label">Example 5. </span>Contents of <span class="ph filepath">mac.ditaval</span></figcaption>
        
        <pre class="pre codeblock"><code>&lt;val&gt;
  &lt;prop att="platform" val="mac" action="include"/&gt;
  &lt;prop att="platform" action="exclude"/&gt;
&lt;/val&gt;</code></pre>
      </figure>
      <figure class="fig fignone" id="example-multiple-ditavalref__fig_d2n_phj_ln"><figcaption><span class="fig--title-label">Example 6. </span>Contents of <span class="ph filepath">linux.ditaval</span></figcaption>
        
        <pre class="pre codeblock"><code>&lt;val&gt;
  &lt;prop att="platform" val="linux" action="include"/&gt;
  &lt;prop att="platform" action="exclude"/&gt;
&lt;/val&gt;</code></pre>
      </figure>
      <div class="p">When a processor evaluates this markup, it results in three copies of the installing
        branch. The following processing takes place:<ul class="ul">
          <li class="li">The first topic (<span class="ph filepath">intro.dita</span>) is published normally, potentially
            using any other DITAVAL conditions that are specified externally.</li>
          <li class="li">The installing branch appears three times, once for each DITAVAL document. The
            branches are created as follows:<ul class="ul">
              <li class="li">The first branch uses the first DITAVAL document
                (<span class="ph filepath">win.ditaval</span>). Resources use their original names as specified
                in the map. The <span class="ph filepath">mac-specific-stuff.dita</span> topic is removed. The
                resulting branch, with indenting to show the hierarchy, matches the original without
                the mac topic:
                <pre class="pre codeblock"><code>install.dita
   do-stuff.dita
     ...more topics and nested branches...
   cleanup.dita
</code></pre></li>
              <li class="li">The second branch uses the second DITAVAL document
                  (<span class="ph filepath">mac.ditaval</span>). Resources are renamed based on the
                  <code class="keyword markupname xmlelement">&lt;dvrResourceSuffix&gt;</code> element. The
                  <span class="ph filepath">mac-specific-stuff.dita</span> topic is included. The resulting
                branch, with indenting to show the hierarchy, is as follows:
                <pre class="pre codeblock"><code>install-apple.dita
   do-stuff-apple.dita
      mac-specific-stuff-apple.dita
      ...more topics and nested branches...
   cleanup-apple.dita
</code></pre></li>
              <li class="li">The third branch uses the last DITAVAL document
                  (<span class="ph filepath">linux.ditaval</span>). Resources are renamed based on the
                  <code class="keyword markupname xmlelement">&lt;dvrResourceSuffix&gt;</code> element. The
                  <span class="ph filepath">mac-specific-stuff.dita</span> topic is removed. The resulting
                branch, with indenting to show the hierarchy, is as follows:
                <pre class="pre codeblock"><code>install-linux.dita
   do-stuff-linux.dita
     ...more topics and nested branches...
   cleanup-linux.dita
</code></pre></li>
            </ul></li>
        </ul></div>
      <p class="p">The example used three DITAVAL documents to avoid triple maintenance of the installing
        branch in a map; the following map is functionally equivalent, but it requires parallel
        maintenance of each branch.</p>
      <figure class="fig fignone" id="example-multiple-ditavalref__fig_akn_phj_ln"><figcaption><span class="fig--title-label">Example 7. </span><span class="ph filepath">input.ditamap</span></figcaption>
        
        <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;topicref href="intro.dita"/&gt;
  <strong class="ph b">&lt;!-- Windows installing branch --&gt;</strong>
  &lt;topicref href="install.dita"&gt;
    &lt;ditavalref href="win.ditaval"/&gt;
    &lt;topicref href="do-stuff.dita"&gt;
      &lt;!-- more topics and nested branches --&gt;
    &lt;/topicref&gt;
    &lt;topicref href="cleanup.dita"/&gt;
  &lt;/topicref&gt;
  <strong class="ph b">&lt;!-- Mac installing branch --&gt;</strong>
  &lt;topicref href="install.dita"&gt;
    &lt;ditavalref href="mac.ditaval"&gt;
      &lt;ditavalmeta&gt;&lt;dvrResourceSuffix&gt;-apple&lt;/dvrResourceSuffix&gt;&lt;/ditavalmeta&gt;
    &lt;/ditavalref&gt;
    &lt;topicref href="do-stuff.dita"&gt;
      &lt;topicref href="mac-specific-stuff.dita" platform="mac"/&gt;
      &lt;!-- more topics and nested branches --&gt;
    &lt;/topicref&gt;
    &lt;topicref href="cleanup.dita"/&gt;
  &lt;/topicref&gt;
  <strong class="ph b">&lt;!-- Linux installing branch --&gt;</strong>
  &lt;topicref href="install.dita"&gt;
    &lt;ditavalref href="linux.ditaval"&gt;
      &lt;ditavalmeta&gt;&lt;dvrResourceSuffix&gt;-linux&lt;/dvrResourceSuffix&gt;&lt;/ditavalmeta&gt;
    &lt;/ditavalref&gt;
    &lt;topicref href="do-stuff.dita"&gt;
      &lt;!-- more topics and nested branches --&gt;
    &lt;/topicref&gt;
    &lt;topicref href="cleanup.dita"/&gt;
  &lt;/topicref&gt;
  &lt;!-- Several chapters worth of other material --&gt;
&lt;/map&gt;</code></pre>
      </figure>
    </div>
  </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title15" lang="en-us" id="example-ditavalref-as-child-of-map">
  <h4 class="title topictitle4" id="ariaid-title15">Example: Single <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> as a child of
      <code class="keyword markupname xmlelement">&lt;map&gt;</code></h4>
  
  <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">In this scenario, a <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element is a direct child of
    the <code class="keyword markupname xmlelement">&lt;map&gt;</code> element, which is equivalent to setting global filtering
    conditions for the map.</p>
    <div class="example non-normative" id="example-ditavalref-as-child-of-map__ditavalref-as-child-of-map"><h5 class="title sectiontitle">Example</h5><p class="non-normative-label">This section is non-normative.</p>
      <p class="p">The following map is equivalent to processing all the contents of the map with the
        conditions in the <span class="ph filepath">novice.ditaval</span> document. If additional conditions are
        provided externally (for example, as a parameter to the publishing process), those
        conditions take precedence.</p>
      <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;title&gt;Sample map&lt;/title&gt;
  &lt;ditavalref href="novice.ditaval"/&gt;
  &lt;!-- lots of content --&gt;
&lt;/map&gt;</code></pre>
    </div>
  </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title16" lang="en-us" id="example-ditavalref-with-mapref">
  <h4 class="title topictitle4" id="ariaid-title16">Example: Single <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> in a reference to a map</h4>
  
  <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">In this scenario, a <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element is used when
    referencing a map. This is equivalent to setting filtering conditions for the referenced
    map.</p>
    <div class="example non-normative" id="example-ditavalref-with-mapref__ditavalref-in-reference-to-map"><h5 class="title sectiontitle">Example</h5><p class="non-normative-label">This section is non-normative.</p>
      <p class="p">In the following example, <span class="ph filepath">other.ditamap</span> is referenced by a root map.
        The <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element indicates that all of the content in
          <span class="ph filepath">other.ditamap</span> is filtered using the conditions specified in the
          <span class="ph filepath">some.ditaval</span> document.</p>
      <figure class="fig fignone"><figcaption><span class="fig--title-label">Example 8. </span>Map fragment</figcaption>
        
        <pre class="pre codeblock"><code>&lt;topicref href="parent.dita"&gt;
  &lt;topicref href="other.ditamap" format="ditamap"&gt;
    &lt;ditavalref href="some.ditaval"/&gt;
  &lt;/topicref&gt;
&lt;/topicref&gt;</code></pre>
      </figure>
      <figure class="fig fignone"><figcaption><span class="fig--title-label">Example 9. </span>Contents of <span class="ph filepath">other.ditamap</span></figcaption>
        
        <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;topicref href="nestedTopic1.dita"&gt;
    &lt;topicref href="nestedTopic2.dita"/&gt;
  &lt;/topicref&gt;
  &lt;topicref href="nestedTopic3.dita"/&gt;
&lt;/map&gt;</code></pre>
      </figure>
      <div class="p">This markup is functionally equivalent to applying the conditions in
          <span class="ph filepath">some.ditaval</span> to the topics that are referenced in the nested map. For
        the purposes of filtering, it could be rewritten in the following way. The extra
          <code class="keyword markupname xmlelement">&lt;topicgroup&gt;</code> container is used here to ensure filtering is not
        applied to <span class="ph filepath">parent.dita</span>, as it would not be in the original
        example:<pre class="pre codeblock"><code>&lt;topicref href="parent.dita"&gt;
  <strong class="ph b">&lt;topicgroup&gt;</strong>
    &lt;ditavalref href="some.ditaval"/&gt;
    &lt;topicref href="nestedTopic1.dita"&gt;
      &lt;topicref href="nestedTopic2.dita"/&gt;
    &lt;/topicref&gt;
    &lt;topicref href="nestedTopic3.dita"/&gt;
  <strong class="ph b">&lt;/topicgroup&gt;</strong>
&lt;/topicref&gt;
</code></pre></div>
      <p class="p">For the purposes of filtering, this map also could be rewritten as follows. </p>
      <pre class="pre codeblock"><code>&lt;topicref href="parent.dita"&gt;
  &lt;topicref href="nestedTopic1.dita"&gt;
    <strong class="ph b">&lt;ditavalref href="some.ditaval"/&gt;</strong>
    &lt;topicref href="nestedTopic2.dita"/&gt;
  &lt;/topicref&gt;
  &lt;topicref href="nestedTopic3.dita"&gt;
    <strong class="ph b">&lt;ditavalref href="some.ditaval"/&gt;</strong>
  &lt;/topicref&gt;
&lt;/topicref&gt;
</code></pre>
      <p class="p">Filtering based on the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element
        applies to the containing element and its children, so in each case, the files
          <span class="ph filepath">nestedTopic1.dita</span>, <span class="ph filepath">nestedTopic2.dita</span>, and
          <span class="ph filepath">nestedTopic3.dita</span> are filtered against the conditions specified in
          <span class="ph filepath">some.ditaval</span>. In each version, <span class="ph filepath">parent.dita</span> is
        not a parent for the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>, so it is not filtered.</p>
    </div>
  </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title17" lang="en-us" id="example-multiple-ditavalref-as-child-of-map">
  <h4 class="title topictitle4" id="ariaid-title17">Example: Multiple <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements as children of
      <code class="keyword markupname xmlelement">&lt;map&gt;</code> in a root map</h4>
  
  <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">In this scenario, multiple instances of the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element
    are specified as direct children of the <code class="keyword markupname xmlelement">&lt;map&gt;</code> element in a root map. This
    is equivalent to setting multiple sets of global filtering conditions for the root
    map.</p>
    <div class="example non-normative" id="example-multiple-ditavalref-as-child-of-map__multiple-ditavalref-as-child-of-map"><h5 class="title sectiontitle">Example</h5><p class="non-normative-label">This section is non-normative.</p>
      <div class="note note note_note non-normative"><span class="note__title">Note<span class="non-normative-label"> (non-normative)</span>:</span> <div class="note__body">Unlike most other examples of branch filtering, this example cannot be rewritten using a
        single valid map with alternate markup that avoids having multiple
          <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements as children of the same grouping element. </div></div>
      <p class="p">Processing the following root map is equivalent to processing all the contents of the map
        with the conditions in the <span class="ph filepath">mac.ditaval</span> file and again with the
          <span class="ph filepath">linux.ditaval</span> file. If additional conditions are provided externally
        (for example, as a parameter to the publishing process), those global conditions take
        precedence.</p>
      <figure class="fig fignone" id="example-multiple-ditavalref-as-child-of-map__fig_ihb_dfh_1r"><figcaption><span class="fig--title-label">Example 10. </span><span class="ph filepath">input.ditamap</span></figcaption>
        
        <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;title&gt;Setting up my product 
on &lt;keyword platform="mac"&gt;Mac&lt;/keyword&gt;&lt;keyword platform="linux"&gt;Linux&lt;/keyword&gt;&lt;/title&gt;
  &lt;topicmeta&gt;
    &lt;othermeta platform="mac"   name="ProductID" content="1234M"/&gt;
    &lt;othermeta platform="linux" name="ProductID" content="1234L"/&gt;
  &lt;/topicmeta&gt;
  &lt;ditavalref href="mac.ditaval"/&gt;
  &lt;ditavalref href="linux.ditaval"/&gt;
  &lt;!-- lots of content, including relationship tables --&gt;
&lt;/map&gt;</code></pre>
      </figure>
      <figure class="fig fignone" id="example-multiple-ditavalref-as-child-of-map__fig_xpd_2fh_1r"><figcaption><span class="fig--title-label">Example 11. </span>Contents of <span class="ph filepath">mac.ditaval</span></figcaption>
        
        <pre class="pre codeblock"><code>&lt;val&gt;
  &lt;prop att="platform" val="mac"   action="include"/&gt;
  &lt;prop att="platform" val="linux" action="exclude"/&gt;
&lt;/val&gt;</code></pre>
      </figure>
      <figure class="fig fignone" id="example-multiple-ditavalref-as-child-of-map__fig_zwb_hfh_1r"><figcaption><span class="fig--title-label">Example 12. </span>Contents of <span class="ph filepath">linux.ditaval</span></figcaption>
        
        <pre class="pre codeblock"><code>&lt;val&gt;
  &lt;prop att="platform" val="mac"   action="exclude"/&gt;
  &lt;prop att="platform" val="linux" action="include"/&gt;
&lt;/val&gt;</code></pre>
      </figure>
      <p class="p">Because the title and metadata each contain filterable content, processing using the
        conditions that are referenced by the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element results in
        two variants of the title and common metadata. While this cannot be expressed using valid
        DITA markup, it is conceptually similar to something like the following.</p>
      <pre class="pre codeblock"><code>&lt;!-- The following wrapperElement is not a real DITA element.
     It is used here purely as an example to illustrate one possible 
     way of picturing the conditions. --&gt;
&lt;wrapperElement&gt;
  &lt;map&gt;
    &lt;title&gt;Setting up my product on &lt;keyword platform="mac"&gt;Mac&lt;/keyword&gt;&lt;/title&gt;
    &lt;topicmeta&gt;
      &lt;othermeta platform="mac"   name="ProductID" content="1234M"/&gt;
    &lt;/topicmeta&gt;
    &lt;ditavalref href="mac.ditaval"/&gt;
    &lt;!-- lots of content, including relationship tables --&gt;
  &lt;/map&gt;
  &lt;map&gt;
    &lt;title&gt;Setting up my product on &lt;keyword platform="linux"&gt;Linux&lt;/keyword&gt;&lt;/title&gt;
    &lt;topicmeta&gt;
      &lt;othermeta platform="linux" name="ProductID" content="1234L"/&gt;
    &lt;/topicmeta&gt;
    &lt;ditavalref href="linux.ditaval"/&gt;
    &lt;!-- lots of content, including relationship tables --&gt;
  &lt;/map&gt;
&lt;/wrapperElement&gt;</code></pre>
      <p class="p">How this map is rendered is implementation dependent. If this root map is rendered as a
        PDF, possible renditions might include the following:</p>
      <ul class="ul">
        <li class="li">Two PDFs, with one using the conditions from <span class="ph filepath">mac.ditaval</span> and
          another using the conditions from <span class="ph filepath">linux.ditaval</span></li>
        <li class="li">One PDF, with a title page that includes each filtered variant of the title and product
          ID, followed by Mac-specific and Linux-specific renderings of the content as chapters in
          the PDF</li>
        <li class="li">One PDF, with the first set of filter conditions used to set book level titles and
          metadata, followed by content filtered with those conditions, followed by content filtered
          with conditions from the remaining <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element.</li>
      </ul>
    </div>
  </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title18" lang="en-us" id="example-multiple-ditavalref-with-mapref">
  <h4 class="title topictitle4" id="ariaid-title18">Example: Multiple <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements in a reference to a
    map</h4>
  
  <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">In this scenario, multiple instances of the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> element
    are specified in a reference to a map. This is equivalent to referencing that map multiple
    times, with each reference nesting one of the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>
    elements.</p>
    <div class="example non-normative" id="example-multiple-ditavalref-with-mapref__multiple-ditavalref-in-reference-to-map"><h5 class="title sectiontitle">Example</h5><p class="non-normative-label">This section is non-normative.</p>
      <p class="p">In the following example, <span class="ph filepath">other.ditamap</span> is referenced by a root map.
        The <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> elements provide conflicting sets of filter
        conditions.</p>
      <figure class="fig fignone" id="example-multiple-ditavalref-with-mapref__fragment"><figcaption><span class="fig--title-label">Example 13. </span>Map fragment</figcaption>
        
        <pre class="pre codeblock"><code>&lt;topicref href="parent.dita"&gt;
  &lt;topicref href="other.ditamap" format="ditamap"&gt;
    &lt;ditavalref href="audienceA.ditaval"/&gt;
    &lt;ditavalref href="audienceB.ditaval"/&gt;
    &lt;ditavalref href="audienceC.ditaval"/&gt;
  &lt;/topicref&gt;
&lt;/topicref&gt;</code></pre>
      </figure>
      <p class="p">This markup is functionally equivalent to referencing <span class="ph filepath">other.ditamap</span>
        three times, with each reference including a single <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>
        elements. The fragment could be rewritten as:</p>
      <figure class="fig fignone" id="example-multiple-ditavalref-with-mapref__fig_szk_hhh_1r"><figcaption><span class="fig--title-label">Example 14. </span>Map fragment</figcaption>
        
        <pre class="pre codeblock"><code>&lt;topicref href="parent.dita"&gt;
  &lt;topicref href="other.ditamap" format="ditamap"&gt;
    &lt;ditavalref href="audienceA.ditaval"/&gt;
  &lt;/topicref&gt;
  &lt;topicref href="other.ditamap" format="ditamap"&gt;
    &lt;ditavalref href="audienceB.ditaval"/&gt;
  &lt;/topicref&gt;
  &lt;topicref href="other.ditamap" format="ditamap"&gt;
    &lt;ditavalref href="audienceC.ditaval"/&gt;
  &lt;/topicref&gt;
&lt;/topicref&gt;</code></pre>
      </figure>
    </div>
  </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title19" lang="en-us" id="example-ditavalref-in-filtered-branch">
  <h4 class="title topictitle4" id="ariaid-title19">Example: <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> within a branch that already uses
      <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code></h4>
  
  <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">In this scenario, a branch is filtered because a <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>
    element is present, and another <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> deeper within that branch
    supplies additional conditions for a subset of the branch.</p>
    <div class="example non-normative" id="example-ditavalref-in-filtered-branch__ditavalref-in-branch-with-ditavalref"><h5 class="title sectiontitle">Example</h5><p class="non-normative-label">This section is non-normative.</p>
      <div class="p">In the following map fragment, a set of operating system conditions applies to installation
        instructions. Within that common branch, a subset of content applies to different
        audiences.<pre class="pre codeblock"><code>&lt;topicref href="install.dita"&gt;
  &lt;ditavalref href="linux.ditaval"/&gt;
  &lt;ditavalref href="mac.ditaval"&gt;
    &lt;ditavalmeta&gt;
      &lt;dvrResourceSuffix&gt;-mac&lt;/dvrResourceSuffix&gt;
    &lt;/ditavalmeta&gt;
  &lt;/ditavalref&gt;
  &lt;ditavalref href="win.ditaval"&gt;
    &lt;ditavalmeta&gt;
      &lt;dvrResourceSuffix&gt;-win&lt;/dvrResourceSuffix&gt;
    &lt;/ditavalmeta&gt;
  &lt;/ditavalref&gt;
  &lt;topicref href="perform-install.dita"&gt;
    &lt;!-- other topics--&gt;
  &lt;/topicref&gt;
  <strong class="ph b">&lt;!-- Begin configuration sub-branch --&gt;</strong>
  &lt;topicref href="configure.dita"&gt;
    &lt;ditavalref href="novice.ditaval"&gt;
      &lt;ditavalmeta&gt;
        &lt;dvrResourceSuffix&gt;-novice&lt;/dvrResourceSuffix&gt;
      &lt;/ditavalmeta&gt;
    &lt;/ditavalref&gt;
    &lt;ditavalref href="advanced.ditaval"&gt;
      &lt;ditavalmeta&gt;
        &lt;dvrResourceSuffix&gt;-admin&lt;/dvrResourceSuffix&gt;
      &lt;/ditavalmeta&gt;
    &lt;/ditavalref&gt;
    &lt;!-- Other config topics --&gt;
  &lt;/topicref&gt;
  <strong class="ph b">&lt;!-- End configuration sub-branch --&gt;</strong>
&lt;/topicref&gt;</code></pre></div>
      <p class="p">In this case, the effective map contains three copies of the complete
        branch. The branches are filtered by operating system. Because topics in the branch are
        filtered in different ways, processors are effectively required to handle three copies of
        the entire branch. The map author uses the <code class="keyword markupname xmlelement">&lt;dvrResourceSuffix&gt;</code>
        elements to control naming for each copy. The Linux branch does not specify a
          <code class="keyword markupname xmlelement">&lt;dvrResourceSuffix&gt;</code> element, because it is the default copy of the
        branch; this allows documents such as <span class="ph filepath">install.dita</span> to retain their
        original names. </p>
      <p class="p">Within each operating system instance, the configuration sub-branch
        is repeated; it is filtered once for novice users and then again for advanced users. As a
        result, there are actually six instances of the configuration sub-branch. Additional
          <code class="keyword markupname xmlelement">&lt;dvrResourceSuffix&gt;</code> elements are used to control naming for each
        instance.</p>
      <ol class="ol">
        <li class="li">The first instance is filtered using the conditions in
            <span class="ph filepath">linux.ditaval</span> and <span class="ph filepath">novice.ditaval</span>. For this
          instance, the resource <span class="ph filepath">configure.dita</span> is treated as the resource
            <span class="ph filepath">configure-novice.dita</span>. There is no renaming based on
            <span class="ph filepath">linux.ditaval</span>, and the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> the
          references <span class="ph filepath">novice.ditaval</span> adds the <code class="ph codeph">suffix -novice</code>. </li>
        <li class="li">The second instance is filtered using the conditions in
            <span class="ph filepath">linux.ditaval</span> and <span class="ph filepath">advanced.ditaval</span>. For this
          instance, the resource <span class="ph filepath">configure.dita</span> is treated as the resource
            <span class="ph filepath">configure-admin.dita</span>. There is no renaming based on
            <span class="ph filepath">linux.ditaval</span>, and the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> that
          references <span class="ph filepath">advanced.ditaval</span> adds the suffix <code class="ph codeph">-admin</code>. </li>
        <li class="li">The third instance is filtered using the conditions in <span class="ph filepath">mac.ditaval</span>
          and <span class="ph filepath">novice.ditaval</span>. For this instance, the resource
            <span class="ph filepath">configure.dita</span> is treated as the resource
            <span class="ph filepath">configure-novice-mac.dita</span>. The <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>
          that references <span class="ph filepath">novice.ditaval</span> adds the suffix
            <code class="ph codeph">-novice</code>, resulting in <span class="ph filepath">configure-novice.dita</span>, and
          then the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> that references
            <span class="ph filepath">mac.ditaval</span> adds the additional suffix <code class="ph codeph">-mac</code>. </li>
        <li class="li">The fourth instance is filtered using the conditions in <span class="ph filepath">mac.ditaval</span>
          and <span class="ph filepath">advanced.ditaval</span>. For this instance, the resource
            <span class="ph filepath">configure.dita</span> is treated as the resource
            <span class="ph filepath">configure-admin-mac.dita</span>. The <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>
          that references <span class="ph filepath">admin.ditaval</span> adds the suffix
          <code class="ph codeph">-admin</code>, resulting in <span class="ph filepath">configure-admin.dita</span>, and then
          the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> that references <span class="ph filepath">mac.ditaval</span>
          adds the additional suffix <code class="ph codeph">-mac</code>. </li>
        <li class="li">The fifth instance is filtered using the conditions in <span class="ph filepath">win.ditaval</span>
          and <span class="ph filepath">novice.ditaval</span>. For this instance, the resource
            <span class="ph filepath">configure.dita</span> is treated as the resource
            <span class="ph filepath">configure-novice-win.dita</span>. The <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>
          that references <span class="ph filepath">novice.ditaval</span> adds the suffix
            <code class="ph codeph">-novice</code>, resulting in <span class="ph filepath">configure-novice.dita</span>, and
          then the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> that references
            <span class="ph filepath">win.ditaval</span> adds the additional suffix <code class="ph codeph">-win</code>. </li>
        <li class="li">The sixth instance is filtered using the conditions in <span class="ph filepath">win.ditaval</span>
          and <span class="ph filepath">advanced.ditaval</span>. For this instance, the resource
            <span class="ph filepath">configure.dita</span> is treated as the resource
            <span class="ph filepath">configure-admin-win.dita</span>. The <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code>
          that references <span class="ph filepath">admin.ditaval</span> adds the suffix
          <code class="ph codeph">-admin</code>, resulting in <span class="ph filepath">configure-admin.dita</span>, and then
          the <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> that references <span class="ph filepath">win.ditaval</span>
          adds the additional suffix <code class="ph codeph">-win</code>. </li>
      </ol>
    </div>
  </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title20" lang="en-us" id="example-ditavalref-error-conditions">
  <h4 class="title topictitle4" id="ariaid-title20">Example: <code class="keyword markupname xmlelement">&lt;ditavalref&gt;</code> error conditions</h4>
  
  <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">In this scenario, multiple, non-equivalent copies of the same resource name are created
    as a result of branch filtering. In addition, the process results in duplicate key names, making
    it impossible to reliably reference individual result topics.</p>
    <div class="example non-normative" id="example-ditavalref-error-conditions__ditavalref-error-conditions"><h5 class="title sectiontitle">Example</h5><p class="non-normative-label">This section is non-normative.</p>
      <p class="p">The following map fragment contains several error conditions that result in name
        clashes:</p>
      <pre class="pre codeblock"><code>&lt;topicref href="a.dita" keys="a"&gt;
  &lt;ditavalref href="one.ditaval"/&gt;
  &lt;ditavalref href="two.ditaval"/&gt;
  &lt;topicref href="b.dita" keys="b"/&gt;
&lt;/topicref&gt;
&lt;topicref href="a.dita"/&gt;
&lt;topicref href="c.dita" keys="c"&gt;
  &lt;ditavalref href="one.ditaval"&gt;
    &lt;ditavalmeta&gt;
      &lt;dvrResourceSuffix&gt;-token&lt;/dvrResourceSuffix&gt;
    &lt;/ditavalmeta&gt;
  &lt;/ditavalref&gt;
  &lt;ditavalref href="two.ditaval"&gt;
    &lt;ditavalmeta&gt;
      &lt;dvrResourceSuffix&gt;-token&lt;/dvrResourceSuffix&gt;
    &lt;/ditavalmeta&gt;
  &lt;/ditavalref&gt;
&lt;/topicref&gt;
</code></pre>
      <div class="p">In this sample, the effective map that results from evaluating the filter conditions has
        several clashes. In some cases the same document must be processed with conflicting
        conditions, using the same URI. In addition, because no key scope is added or modified, keys
        in the branch are duplicated in such a way that only one version is available for use. When
        the branches are evaluated to create distinct copies, the filtered branches result in the
        following equivalent
        map:<pre class="pre codeblock"><code>&lt;topicref href="a.dita" keys="a"&gt; &lt;!-- a.dita to be filtered by one.ditaval --&gt;
  &lt;topicref href="b.dita" keys="b"/&gt;  &lt;!-- b.dita to be filtered by one.ditaval --&gt;
&lt;/topicref&gt;
&lt;topicref href="a.dita" keys="a"&gt; &lt;!-- a.dita to be filtered by two.ditaval; key "a" ignored --&gt;
  &lt;topicref href="b.dita" keys="b"/&gt;  &lt;!-- b.dita to be filtered by two.ditaval; key "b" ignored --&gt;
&lt;/topicref&gt;
&lt;topicref href="a.dita"/&gt;
&lt;topicref href="c-token.dita" keys="c"&gt; 
  &lt;!-- c-token.ditaval to be filtered by one.ditaval --&gt;
&lt;/topicref&gt;
&lt;topicref href="c-token.dita" keys="c"&gt; 
  &lt;!-- c-token.ditaval to be filtered by two.ditaval, key "c" ignored --&gt;
&lt;/topicref&gt;</code></pre>
      </div>
      <div class="p">The equivalent map highlights several problems with the original source:<ul class="ul">
          <li class="li">The key names "a" and "b" are present in a branch that will be duplicated. No key
            scope is introduced for either version of the branch, meaning that the keys will be
            duplicated. Because there can only be one effective key definition for "a" or "b", it
            only is possible to reference one version of the topic using keys.</li>
          <li class="li">The key name "c" is present on another branch that will be duplicated, resulting in
            the same problem.</li>
          <li class="li">The file <span class="ph filepath">c.dita</span> is filtered with two sets of conditions, each of
            which explicitly maps the filtered resource to <span class="ph filepath">c-token.dita</span>. This
            is an error condition that processors need to report.</li>
          <li class="li">In situations where resource names map directly to output file names, such as an HTML5
            rendering that creates files based on the original resource name, the following name
            conflicts also occur. In this case a processor would need to report an error, use an
            alternate naming scheme, or both:<ol class="ol">
              <li class="li"><span class="ph filepath">a.dita</span> generates <span class="ph filepath">a.html</span> using three
                alternate set of conditions. One version uses <span class="ph filepath">one.ditaval</span>, one
                version uses <span class="ph filepath">two.ditaval</span>, and the third version uses no
                filtering.</li>
              <li class="li"><span class="ph filepath">b.dita</span> generates <span class="ph filepath">b.html</span> using two
                alternate set of conditions. One version uses <span class="ph filepath">one.ditaval</span>, and
                the other version uses <span class="ph filepath">two.ditaval</span>.</li>
            </ol></li>
        </ul></div>
    </div>
  </div>
</article></article></article></article><aside class="section-toc" role="aside"></aside></article></main>
