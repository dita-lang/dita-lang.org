---
layout: base.njk
title: ''
index: 'toc.html'
notices: 'resources/oasis-notices.html'
commit: 'ec1db616fc038fc6d956c81c0e041b96309e505b'
repository: 'oasis-tcs/dita'
classes: ''
---

<nav class="toc" role="toc"><ul><li><a href="introduction/dita-release-overview.html">Introduction</a></li><li><a href="archSpec/base/dita-terminology.html">DITA terminology, notation, and conventions</a></li><li><a href="archSpec/base/introduction-to-dita.html">Overview of DITA</a></li><li><a href="archSpec/base/accessibility-and-translation.html">Accessibility and translation</a></li><li><a href="archSpec/base/dita-map-processing.html">DITA map processing</a></li><li><a href="archSpec/base/ditaaddressing.html">DITA addressing</a><ul class="nav nav-list"><li><a href="archSpec/base/id.html#id">id attribute</a></li><li><a href="archSpec/base/dita-linking.html#dita-linking">DITA linking</a></li><li><a href="archSpec/base/uri-based-addressing.html#uri-based-addressing">URI-based (direct) addressing</a></li><li class="active"><a href="Chunk563375964.html#Chunk563375964">Key-based addressing</a><ul class="nav nav-list"><li><a href="Chunk563375964.html#key-based_addressing">Indirect key-based addressing</a></li></ul></li><li><a href="archSpec/base/context-hooks-for-user-assistance.html#context-hooks-for-user-assistance">Context hooks for user assistance</a></li></ul></li><li><a href="archSpec/base/behaviors.html">DITA processing</a></li><li><a href="archSpec/base/configuration-specialization-and-constraints.html">Configuration and specialization </a></li><li><a href="langRef/langRef-base.html">Element reference</a></li><li><a href="conformance/conformance.html">Conformance</a></li><li><a href="acknowledgments/acknowledgments.html#r-acknowledgments">Acknowledgments</a></li><li><a href="non-normative/aggregated-RFC-2119-statements.html#aggregated-RFC-2119-statements">Aggregated RFC-2119 statements</a></li><li><a href="archSpec/base/coding-requirements.html#coding-practices">Coding practices for DITA grammar files</a></li><li><a href="non-normative/developing-constraint-and-expansion-modules.html#developing-constraint-and-expansion-modules">Constraint modules</a></li><li><a href="non-normative/expansion-modules.html#expansion-modules">Expansion modules</a></li><li><a href="non-normative/elementsMerged.html#elements">Element-by-element recommendations for translators</a></li><li><a href="non-normative/formatting-expectations.html#formatting-expectations">Formatting expectations</a></li><li><a href="non-normative/migrating-to-dita-2.0.html#migrating-to-dita-2.0">Migrating to DITA 2.0</a></li><li><a href="non-normative/basedoctypes.html#oasisdomains">OASIS grammar files</a></li><li><a href="non-normative/interoperability-considerations.html#nteroperability-considerations">Processing interoperability considerations</a></li><li><a href="non-normative/revision-history.html#revision-history">Revision history</a></li></ul></nav><main role="main" class=""><article role="article" aria-labelledby="ariaid-title1"><article class="nested0" aria-labelledby="ariaid-title1" id="Chunk563375964"><h1 class="title topictitle1" id="ariaid-title1">Key-based addressing</h1><nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="archSpec/base/ditaaddressing.html" title="DITA provides two addressing mechanisms. DITA addresses either are direct URI-based addresses, or they are indirect key-based addresses. Within DITA documents, individual elements are addressed by unique identifiers specified on the id attribute. DITA defines two fragment-identifier syntaxes; one is the full fragment-identifier syntax, and the other is an abbreviated fragment-identifier syntax that can be used when addressing non-topic elements from within the same topic.">DITA addressing</a></div></div></nav><article class="topic concept nested1" aria-labelledby="ariaid-title2" lang="en-us" id="key-based_addressing">
    <h2 class="title topictitle2" id="ariaid-title2">Indirect key-based addressing</h2>
    
    <div class="body conbody"><p class="shortdesc">DITA keys provide an alternative to direct addressing. The key reference mechanism
        provides a layer of indirection so that resources (for example, URIs, metadata, or variable
        text strings) can be defined at the DITA map level instead of locally in each
        topic.</p>
        <p class="p">For information about using keys to define and reference controlled
            values, see <a class="xref" href="Chunk1869436731.html#concept_gfn_skx_54" title="Subject scheme maps can be used to define controlled values and subject definitions. The controlled values can be bound to attributes, as well as element and attribute pairs. The subject definitions can contain metadata and provide links to more detailed information; they can be used to classify content and provide semantics that can be used in taxonomies and ontologies.">Subject scheme maps and their usage</a>.</p>
        <div class="note note note_note non-normative"><span class="note__title">Note<span class="non-normative-label"> (non-normative)</span>:</span> <div class="note__body">The material in this section of the DITA specification is
            exceptionally complex; it is targeted at implementers who build processors and other
            rendering applications.</div></div>
        
        
        
    </div>
<article class="topic concept nested2" aria-labelledby="ariaid-title3" lang="en-us" id="concept_igf_3c4_kn">
 <h3 class="title topictitle3" id="ariaid-title3">Core concepts for working with keys</h3>
 
 <div class="body conbody"><p class="shortdesc"> The concepts described below are critical for a full understanding of keys and key
  processing.</p>
    <section class="section" id="concept_igf_3c4_kn__section">
      
      <p class="p">The use of the phases "<code class="keyword markupname xmlelement">&lt;map&gt;</code> element" or
          "<code class="keyword markupname xmlelement">&lt;topicref&gt;</code> element" should be interpreted as
          "<code class="keyword markupname xmlelement">&lt;map&gt;</code> element and any specialization of
          <code class="keyword markupname xmlelement">&lt;map&gt;</code> element " or " <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> element or
        any specialization of <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> element."</p>
    </section>
  <section class="section" id="concept_igf_3c4_kn__definitions"><h4 class="title sectiontitle">Definitions related to keys</h4>
   
   <dl class="dl">
    
     <dt class="dt dlterm" id="concept_igf_3c4_kn__resource">resource</dt>
     <dd class="dd">For the purposes of keys and key resolution, one of the following:<ul class="ul">
              <li class="li">An object addressed by URI</li>
              <li class="li">Metadata specified on a resource, such as a <code class="keyword markupname xmlatt">@scope</code> or
                  <code class="keyword markupname xmlatt">@format</code> attribute</li>
              <li class="li">Text or metadata located within a <code class="keyword markupname xmlelement">&lt;topicmeta&gt;</code> element</li>
            </ul></dd>
    
    
     <dt class="dt dlterm" id="concept_igf_3c4_kn__key">key</dt>
     <dd class="dd">A name for a resource. <span class="ph">See <a class="xref" href="Chunk563375964.html#using-keys-for-addressing" title="For topic references, image references, and other link relationships, resources can be indirectly addressed by using the keyref attribute. For content reference relationships, resources can be indirectly addressed by using the conkeyref attribute.">Using keys for addressing</a>
              for more information.</span></dd>
    
    
     <dt class="dt dlterm" id="concept_igf_3c4_kn__key-definition">key definition</dt>
     <dd class="dd">A <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> element that binds one or more key names to <span class="ph">zero or more</span> resources.</dd>
    
    
     <dt class="dt dlterm" id="concept_igf_3c4_kn__key-reference">key reference</dt>
     <dd class="dd">An attribute that references a key, such as <code class="keyword markupname xmlatt">@keyref</code> or
              <code class="keyword markupname xmlatt">@conkeyref</code>.</dd>
    
    
     <dt class="dt dlterm" id="concept_igf_3c4_kn__key-space">key space</dt>
     <dd class="dd">A list of key definitions that are used to resolve key references.</dd>
    
    
     <dt class="dt dlterm" id="concept_igf_3c4_kn__effective-key-definition">effective key definition</dt>
     <dd class="dd">The definition for a key within a key space that is used to resolve references to that key.
      A key might have multiple definitions within a key space, but only one of those definitions is
      effective.</dd>
    
    
     <dt class="dt dlterm" id="concept_igf_3c4_kn__key-scope">key scope</dt>
     <dd class="dd">A map or section of a map that defines its own key space and serves as the resolution
      context for its key references.</dd>
    
   </dl>
  </section>
  <section class="section" id="concept_igf_3c4_kn__key-definition-full"><h4 class="title sectiontitle">Key definitions</h4>
   
   <p class="p"><span class="ph">A key definition binds one or more keys to zero or more resources. <span class="ph">Resources can be:</span></span></p>
   <ul class="ul">
        <li class="li">Any <span class="ph">URI-addressed resource</span> that is referenced directly by the
            <code class="keyword markupname xmlatt">@href</code> attribute or indirectly by the <code class="keyword markupname xmlatt">@keyref</code> attribute
            <span class="ph">on the key definition</span>. References to the key are
          considered references to <span class="ph">the URI-addressed resource</span>.</li>
        <li class="li"><span class="ph">(If the key definition contains a child
              <code class="keyword markupname xmlelement">&lt;topicmeta&gt;</code> element) The child elements of the
              <code class="keyword markupname xmlelement">&lt;topicmeta&gt;</code> element.</span> The content of those elements can be
          used to populate the content of elements that reference <span class="ph">the
            key</span>.</li>
      </ul>
   <p class="p">If a key definition does not contain a <code class="keyword markupname xmlelement">&lt;topicmeta&gt;</code> element and does not
          <span class="ph">refer to</span> a resource by <code class="keyword markupname xmlatt">@href</code> or
          <code class="keyword markupname xmlatt">@keyref</code>, it is nonetheless a valid key definition. References to the key
        definition are considered resolvable, but no linking or content <span class="ph">transclusion</span> occurs.</p>
  </section>
  <section class="section" id="concept_igf_3c4_kn__key-scope-full"><h4 class="title sectiontitle">Key scopes</h4>
   
      <p class="p">All key definitions and key references exist within a key scope. <span class="ph">If the <code class="keyword markupname xmlatt">@keyscope</code> attribute is never specified within the map hierarchy,
          all keys exist within a single, default key scope.</span></p>
      <p class="p"><span class="ph">Additional key scopes are created when the
            <code class="keyword markupname xmlatt">@keyscope</code> attribute is used.</span> The <code class="keyword markupname xmlatt">@keyscope</code>
        attribute specifies a name or names for the scope. Within a map hierarchy, key scopes are
        bounded by the following:</p>
   <ul class="ul" id="concept_igf_3c4_kn__ul_nfz_hjp_kn">
    <li class="li">The root map.</li>
    <li class="li">The root element of submaps <span class="ph">when the root elements of the
            submaps</span> specify the <code class="keyword markupname xmlatt">@keyscope</code> attribute</li>
    <li class="li">Any <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> elements that specify the <code class="keyword markupname xmlatt">@keyscope</code>
          attribute</li>
   </ul>
  </section>
  <section class="section" id="concept_igf_3c4_kn__key-space-full"><h4 class="title sectiontitle">Key spaces</h4>
   
      <p class="p">The key space associated with a key scope is used to resolve all key references that occur
        immediately within that scope. Key references in child scopes are resolved using the key
        spaces that are associated with those child scopes.</p>
   <p class="p">A key scope is associated with exactly one key space. That key space contains all key
        definitions that are located directly within the scope; it <span class="ph">might</span> also contain definitions that exist in other scopes. Specifically, the key
        space associated with a key scope is comprised of the following key definitions, in order of
        precedence:</p>
   <ol class="ol" id="concept_igf_3c4_kn__ol_w41_rjp_kn">
    <li class="li">All key definitions from the key space associated with the parent key scope,
          if any.</li>
    <li class="li">Key definitions within the scope-defining element, including those defined in
          directly-addressed, locally-scoped submaps, but excluding those defined in child scopes.
            <span class="ph">(Keys defined in child scopes cannot be addressed without
            qualifiers.)</span></li>
    <li class="li">The key definitions from child scopes, with each key prepended by the child scope name
          followed by a period. If a child scope has multiple names, the keys in that scope are
          addressable from the parent scope using any of the scope names as a prefix.</li>
   </ol>
   <div class="note note note_note non-normative"><span class="note__title">Note<span class="non-normative-label"> (non-normative)</span>:</span> <div class="note__body">Because of rules 1 and 3, the key space that is associated with a child scope includes the
        scope-qualified copies of its own keys that are inherited from the key space of the parent
        scope, as well as those from other "sibling" scopes.</div></div>
  </section>
  <section class="section" id="concept_igf_3c4_kn__effective-key-definition-full"><h4 class="title sectiontitle">Effective key definitions</h4>
      
      <p class="p">A key space can contain many definitions for a given key, but only one definition is
        effective for the purpose of resolving key references.</p>
      <p class="p">When a key has a definition in the key space that is <span class="ph">inherited from</span> a parent scope, that definition is effective.
        Otherwise, a key definition is effective if it is first in a breadth-first traversal of the
        locally-scoped submaps beneath the scope-defining element. <span class="ph">Put
          another way, a key definition is effective if it is the first definition for that key name
          in the shallowest map that contains that key definition.</span> This allows higher-level map
        authors to override keys defined in referenced submaps.</p>
      <div class="note note note_note non-normative"><span class="note__title">Note<span class="non-normative-label"> (non-normative)</span>:</span> <div class="note__body">A key definition that specifies more than one key name in its <code class="keyword markupname xmlatt">@keys</code>
        attribute <span class="ph">might</span> be the effective definition for some of its
        keys but not for others.</div></div>
      <p class="p">Within a key scope, keys do not have to be defined before they are referenced. The key
        space is effective for the entire scope, so the order of key definitions and key references
        relative to one another is not significant. <span class="ph">This has the following
          implications for processors:</span></p>
      <ul class="ul">
        <li class="li">All key spaces for a root map must be determined before any key reference processing can
          be performed.</li>
        <li class="li">Maps referenced solely by key reference have no bearing on key space contents.</li>
      </ul>
      <p class="p"><span class="ph">For purposes of key definition
          precedence, the scope-qualified key definitions from a child scope are considered to occur
          at the location of the scope-defining element within the parent scope.</span>
        <span class="ph example">See <a class="xref" href="Chunk563375964.html#example-key-precedence-with-scopes" title="For purposes of key definition precedence, the scope-qualified key definitions from a child scope are considered to occur at the location of the scope-defining element within the parent scope.">Example: How key scopes affect key precedence</a> for
          more information.</span></p>
    </section>
 </div>
</article><article class="topic reference nested2" aria-labelledby="ariaid-title4" lang="en-us" id="thekeysattribute">
 <h3 class="title topictitle3" id="ariaid-title4">Setting key names with the <code class="keyword markupname xmlatt">@keys</code> attribute</h3>
 
 
 <div class="body refbody"><p class="shortdesc">A <code class="keyword markupname xmlatt">@keys</code> attribute consists of one or more space-separated keys. Map
  authors define keys using a <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> or <code class="keyword markupname xmlelement">&lt;topicref&gt;</code>
  specialization that contains the <code class="keyword markupname xmlatt">@keys</code> attribute. Each key definition introduces
  an identifier for a resource referenced from a map. Keys resolve to the resources given as the
   <code class="keyword markupname xmlatt">@href</code> value on the key definition <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> element, to
  content contained within the key definition <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> element, or
  both.</p>
  <section class="section" id="thekeysattribute__section-1">
   
   <div class="p">The <code class="keyword markupname xmlatt">@keys</code> attribute uses the
                                following syntax:<ul class="ul" id="thekeysattribute__ul_yxs_dr5_yl">
                                        <li class="li">The value of the <code class="keyword markupname xmlatt">@keys</code> attribute is one
                                                or more space-separated key names.</li>
                                        <li class="li"> Key names consist of characters that are legal in a
                                                URI. The case of key names is significant.</li>
                                        <li class="li">The following characters are prohibited in key names:
                                                "{", "}", "[", "]", "/", "#", "?", and whitespace
                                                characters.</li>
                                </ul></div>
   <p class="p">A key <span class="ph">cannot</span> resolve to sub-topic elements, although a
     <code class="keyword markupname xmlatt">@keyref</code> attribute <span class="ph">can</span> do so by combining a key
    with a sub-topic element id.</p>
  </section>
 </div>
<nav role="navigation" class="related-links"><div class="linklist relconcepts" lang="en-us"><strong>Related concepts</strong><br><ul class="linklist"><li class="linklist"><a class="link" href="Chunk563375964.html#key-based_addressing" title="DITA keys provide an alternative to direct addressing. The key reference mechanism provides a layer of indirection so that resources (for example, URIs, metadata, or variable text strings) can be defined at the DITA map level instead of locally in each topic.">Indirect key-based addressing</a></li></ul></div></nav></article><article class="topic reference nested2" aria-labelledby="ariaid-title5" lang="en-us" id="thekeyrefattribute">
 <h3 class="title topictitle3" id="ariaid-title5">The <code class="keyword markupname xmlatt">@keyref</code> attribute</h3>
 
 
 <div class="body refbody"><p class="shortdesc">The <code class="keyword markupname xmlatt">@keyref</code> attribute provides an indirect, late-bound reference to
  topics, to collections of topics (ditabase), to maps, to referenceable portions of maps, to
  non-DITA documents, to external URIs, or to XML content contained within a key definition topic
  reference. When the DITA content is processed, the key references are resolved using key
  definitions from DITA maps.</p>
  <section class="section" id="thekeyrefattribute__section-1">
   
   <p class="p">For elements that only refer to topics or non-DITA resources, the value of the
     <code class="keyword markupname xmlatt">@keyref</code> attribute is a key name. For elements that <span class="ph">can</span> refer to elements within maps or topics, the value of the <code class="keyword markupname xmlatt">@keyref</code>
    attribute is a key name, a <span class="ph">slash</span> ("/"), and the ID of the target element, where the key
    name must be bound to either the map or topic that contains the target element. </p>
  </section>
 </div>
<nav role="navigation" class="related-links"><div class="linklist relconcepts" lang="en-us"><strong>Related concepts</strong><br><ul class="linklist"><li class="linklist"><a class="link" href="Chunk563375964.html#key-based_addressing" title="DITA keys provide an alternative to direct addressing. The key reference mechanism provides a layer of indirection so that resources (for example, URIs, metadata, or variable text strings) can be defined at the DITA map level instead of locally in each topic.">Indirect key-based addressing</a></li></ul></div></nav></article><article class="topic concept nested2" aria-labelledby="ariaid-title6" lang="en-us" id="using-keys-for-addressing">
    <h3 class="title topictitle3" id="ariaid-title6"><span class="ph">Using keys for addressing</span></h3>
    
    <div class="body conbody"><p class="shortdesc">For topic references, image references, and other link relationships, resources can
        be indirectly addressed by using the <code class="keyword markupname xmlatt">@keyref</code> attribute. For content
        reference relationships, resources can be indirectly addressed by using the
            <code class="keyword markupname xmlatt">@conkeyref</code> attribute.</p>
        <section class="section" id="using-keys-for-addressing__syntax"><h4 class="title sectiontitle">Syntax</h4>
            
            <p class="p">For references to topics, maps, and non-DITA resources, the value of the
                    <code class="keyword markupname xmlatt">@keyref</code> attribute is simply a key name (for example,
                    <code class="ph codeph">keyref="topic-key"</code>). </p>
            <p class="p"><span class="ph">For references to non-topic elements within topics,</span>
                the value of the <code class="keyword markupname xmlatt">@keyref</code> attribute is a key name, a <span class="ph">slash</span> ("/"), and the ID of the target element (for
                example, <code class="ph codeph">keyref="topic-key/some-element-id"</code>.)</p>
            
        </section>
        <div class="example non-normative" id="using-keys-for-addressing__example"><h4 class="title sectiontitle">Example</h4><p class="non-normative-label">This section is non-normative.</p>
            
            <div class="p">For example, consider this topic in the document <span class="ph filepath">file.dita</span>:
                <pre class="pre codeblock"><code>&lt;topic id="topicid"&gt;
 &lt;title&gt;Example referenced topic&lt;/title&gt;
 &lt;body&gt;
  &lt;section id="section-01"&gt;Some content.&lt;/section&gt;
 &lt;/body&gt;
&lt;/topic&gt;</code></pre>and
                this key
                definition:<pre class="pre codeblock"><code>&lt;map&gt;
  &lt;topicref keys="myexample"
    href="file.dita"
  /&gt;
&lt;/map&gt;</code></pre></div>
            <p class="p">A cross reference of the form <code class="ph codeph">keyref="myexample/section-01"</code> resolves
                to the <code class="keyword markupname xmlelement">&lt;section&gt;</code> element in the topic. The key reference is
                equivalent to the URI reference
                <code class="ph codeph">xref="file.dita#topicid/section-01"</code>.</p>
        </div>
    </div>
</article><article class="topic concept nested2" aria-labelledby="ariaid-title7" lang="en-us" id="concept_nsb_nv4_3q">
 <h3 class="title topictitle3" id="ariaid-title7">Key scopes</h3>
 
 <div class="body conbody"><p class="shortdesc">Key scopes enable map authors to specify different sets of key definitions for different
    map branches.</p>
    <p class="p">A key scope is defined by a <code class="keyword markupname xmlelement">&lt;map&gt;</code> or <code class="keyword markupname xmlelement">&lt;topicref&gt;</code>
      element that specifies the <code class="keyword markupname xmlatt">@keyscope</code> attribute. The <code class="keyword markupname xmlatt">@keyscope</code>
      attribute specifies the names of the scope, separated by spaces. The
        legal characters for a key scope name are the same as those for keys.</p>
    <p class="p">A key scope includes the following components:</p>
    <ul class="ul">
      <li class="li">The scope-defining element</li>
      <li class="li">The elements that are contained by the scope-defining element, minus the elements that are
        contained by child key scopes</li>
      <li class="li">The elements that are referenced by the scope-defining element or its descendants, minus
        the elements that are contained by child key scopes</li>
    </ul>
    <p class="p">If the <code class="keyword markupname xmlatt">@keyscope</code> attribute is specified on both a
      reference to a DITA map and the root element of the referenced map, only one scope is created;
      the submap does not create another level of scope hierarchy. The single key scope that results
      from this scenario has multiple names; its names are the union of the values of the
        <code class="keyword markupname xmlatt">@keyscope</code> attribute on the map reference and the root element of the submap.
      This means that processors can resolve references to both the key scopes specified on the map
      reference and the key scopes specified on the root element of the submap.</p>
    <p class="p">The root element of a root map always defines a key scope, regardless of whether a
        <code class="keyword markupname xmlatt">@keyscope</code> attribute is present. All key definitions and key references exist
      within a key scope, even if it is an unnamed, implicit key scope that is defined by the root
      element in the root map.</p>
    <p class="p">Each key scope has its own key space that is used to resolve the key references that occur
      within the scope. The key space that is associated with a key scope includes all of the key
      definitions within the key scope. This means that different key scopes can have different
      effective key definitions:</p>
    <ul class="ul">
      <li class="li">A given key can be defined in one scope, but not another.</li>
      <li class="li"> A given key also can be defined differently in different key scopes.</li>
    </ul>
    <p class="p"> Key references in each key scope are resolved using the effective key definition that is
      specified within its own key scope.</p>
    
    <div class="example non-normative" id="concept_nsb_nv4_3q__example-1"><h4 class="title sectiontitle">Example: Key scopes specified on both the map reference and the root element of the
        submap</h4><p class="non-normative-label">This section is non-normative.</p>
      
      <p class="p">Consider the following scenario:</p>
      <figure class="fig fignone"><figcaption><span class="fig--title-label">Example 1. </span>Root map</figcaption>
        
        <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;mapref keyscope="A" href="installation.ditamap"/&gt;
  &lt;!-- ... --&gt;
&lt;/map&gt;</code></pre>
      </figure>
      <figure class="fig fignone"><figcaption><span class="fig--title-label">Example 2. </span><span class="ph filepath">installation.ditamap</span></figcaption>
        
        <pre class="pre codeblock"><code>&lt;map keyscope="B"&gt;
  &lt;!-- ... --&gt;
&lt;/map&gt;</code></pre>
      </figure>
      <p class="p">Only one key scope is created; it has key scope names of "A" and "B".</p>
    </div>
  </div>
</article><article class="topic reference nested2" aria-labelledby="ariaid-title8" lang="en-us" id="keyscope-attribute">
  <h3 class="title topictitle3" id="ariaid-title8">The <code class="keyword markupname xmlatt">@keyscope</code> attribute</h3>
  
  
  <div class="body refbody"><p class="shortdesc">The <code class="keyword markupname xmlatt">@keyscope</code> attribute consists of one or more space-separated key
    scope names. Map authors define the boundaries for key scopes by specifying the
      <code class="keyword markupname xmlatt">@keyscope</code> attribute on <code class="keyword markupname xmlelement">&lt;map&gt;</code> elements,
      <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> elements, or elements that are specializations of
      <code class="keyword markupname xmlelement">&lt;map&gt;</code> or <code class="keyword markupname xmlelement">&lt;topicref&gt;</code>. Such elements, their
    contents, and any locally-scoped content referenced from within the element, are considered to
    be part of the scope. Keys defined within a scope are only directly referenceable from within
    the same scope. They can be referenced from the parent scope using the scope's name, followed by
    a period, followed by the key name.</p>
    <section class="section" id="keyscope-attribute__duplicate-scope">
      
      <p class="p" id="keyscope-attribute__non-intersecting">All key scopes are contiguous and non-intersecting. Within a root
        map, two distinct key scopes with the same name have no relationship with each other aside
        from that implied by their relative locations in the key scope hierarchy. They do not, for
        example, share key definitions. The only processing impact of a key scope's names is in
        defining the prefixes used when contributing qualified key names to the parent scope. For
        example, consider the following map segment:</p>
      <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;topicgroup keyscope="xyz" id="scope1"&gt;
    &lt;keydef keys="a" id="def1"/&gt;
    &lt;!-- other topic references --&gt;
  &lt;/topicgroup&gt;
  &lt;topicgroup keyscope="xyz" id="scope2"&gt;
    &lt;keydef keys="a" id="def2"/&gt;
    &lt;!-- other topic references --&gt;
  &lt;/topicgroup&gt;
  &lt;!-- lots of other content --&gt;
&lt;/map&gt;</code></pre>
      <p class="p">This map creates two distinct scopes that happen to use the same name
          (<span class="keyword">xyz</span>). This results in the following:</p>
      <ul class="ul">
        <li class="li">Each <code class="keyword markupname xmlelement">&lt;topicgroup&gt;</code> sets a scope of <span class="keyword">xyz</span> and
          includes a key <span class="keyword">a</span>. From outside of those two scopes, references to
            <code class="ph codeph">keyref="xyz.a"</code> (key <span class="keyword">a</span> within the scope
            <span class="keyword">xyz</span>) will always resolve to the first instance of that value, which
          is in the first <code class="keyword markupname xmlelement">&lt;topicgroup&gt;</code>.</li>
        <li class="li">Within the first <code class="keyword markupname xmlelement">&lt;topicgroup&gt;</code>, content uses
            <code class="ph codeph">keyref="a"</code> will resolve to the key in that branch (defined on the
          element with <code class="ph codeph">id="def1"</code>).</li>
        <li class="li">Within the second <code class="keyword markupname xmlelement">&lt;topicgroup&gt;</code>, content uses
            <code class="ph codeph">keyref="a"</code> will resolve to the key in that branch (defined on the
          element with <code class="ph codeph">id="def2"</code>).</li>
      </ul>
    </section>
  </div>
</article><article class="topic concept nested2" aria-labelledby="ariaid-title9" lang="en-us" id="concept_art_5ps_sr"> 
  <h3 class="title topictitle3" id="ariaid-title9">Addressing keys across scopes</h3> 
   
  <div class="body conbody"><p class="shortdesc">When referencing key definitions that are defined in a different key scope, key names
		might need to be qualified with key scope names. </p> 
	 <p class="p">A root map might contain any number of key scopes; relationships between
		key scopes are discussed using the following terms: 
	 </p> 
	 <dl class="dl"> 
		 
		  <dt class="dt dlterm">child scope 
		  </dt> 
		  <dd class="dd">A key scope that occurs directly within another key scope. For
			 example, in the figure below, key scopes "A-1" and "A-2" are child scopes of
			 key scope "A". 
		  </dd> 
		 
		 
		  <dt class="dt dlterm">parent scope 
		  </dt> 
		  <dd class="dd">A key scope that occurs one level above another key scope. For
			 example, in the figure below, key scope "A" is a parent scope of key scopes
			 "A-1" and "A-2". 
		  </dd> 
		 
		 
		  <dt class="dt dlterm">ancestor scope 
		  </dt> 
		  <dd class="dd">A key scope that occurs any level above another key scope. For
			 example, in the figure below, key scopes "A" and "Root" are both ancestor
			 scopes of key scopes "A-1" and "A-2" 
		  </dd> 
		 
		 
		  <dt class="dt dlterm">descendant scope 
		  </dt> 
		  <dd class="dd">A key scope that occurs any level below another key scope. For
			 example, in the figure below, key scopes "A", "A-1", and "A-2" are all
			 descendant scopes of the implicit, root key scope 
		  </dd> 
		 
		 
		  <dt class="dt dlterm">sibling scope 
		  </dt> 
		  <dd class="dd">A key scope that shares a common parent with another key scope. For
			 example, in the figure below, key scopes "A" and "B" are sibling scopes; they
			 both are children of the implicit, root key scope. 
		  </dd> 
		 
		 
		  <dt class="dt dlterm">key scope hierarchy 
		  </dt> 
		  <dd class="dd">A key scope and all of its descendant scopes. 
		  </dd> 
		 
	 </dl> 
	 <figure class="fig fignone" id="concept_art_5ps_sr__fig_DE65294F6EF64C129F38A19C66C40E3E"><figcaption><span class="fig--title-label">Figure 3. </span>A key scope hierarchy</figcaption> 
		 
		<br><img class="image" id="concept_art_5ps_sr__image_3BFFE5D941FD4EB6BD976801585C893A" src="images/key-scope-hierarchy.png" alt="Tree structure diagram showing a key scope hierarchy. The leftmost node is labeled 'Root'. There are two child nodes of Root labeled 'A' and 'B'. Node A has two children labeled 'A-1' and 'A-2'. Node B has two children labeled 'B-1' and 'B-2'."><br> 
	 </figure> 
	 <section class="section" id="concept_art_5ps_sr__keys-in-parent-key-scope"><h4 class="title sectiontitle">Keys that are defined in parent key scopes</h4> 
		 
		<p class="p">The key space that is associated with a key scope also includes all
		  key definitions from its parent key scope. If a key name is defined in both a
		  key scope and its parent scope, the key definition in the parent scope takes
		  precedence. This means that a key definition in a parent scope overrides all
		  definitions for the same key name in all descendant scopes. This enables map
		  authors to override the keys that are defined in submaps, regardless of whether
		  the submaps define key scopes. 
		</p> 
		<p class="p">In certain complex cases, a scope-qualified key name (such as <span class="keyword">scope.key</span>) can
				override an unqualified key name from the parent scope. See <a class="xref" href="Chunk563375964.html#example-key-precedence-with-scopes" title="For purposes of key definition precedence, the scope-qualified key definitions from a child scope are considered to occur at the location of the scope-defining element within the parent scope.">Example: How key scopes affect key precedence</a>. </p> 
	 </section> 
	 <section class="section" id="concept_art_5ps_sr__keys-in-child-key-scope"><h4 class="title sectiontitle">Keys that are defined in child key scopes</h4> 
		 
		<p class="p">The key space associated with a key scope does not include the 
		  <em class="ph i">unqualified</em> key definitions from the child scopes. However, it
		  does include scope-qualified keys from the child scopes. This enables sibling
		  key scopes to have different key definitions for the same key name. 
		</p> 
		<p class="p">A 
		  <dfn class="term">scope-qualified key name</dfn> is a key name, prepended by one
		  or more key scope names 
		  <span class="ph">and separated by periods</span>. For example, to reference a key
		  "keyName" defined in a child scope named "keyScope", specify 
		  <code class="ph codeph">keyref="keyScope.keyName"</code>. 
		</p> 
		<p class="p">If a key scope has multiple names, its keys can be addressed from its
		  parent scope using any of the scope names. For example, if a key scope is
		  defined with 
		  <code class="ph codeph">keyscope="a b c"</code>, and it contains a key name of
		  "product", that key can be referenced from the parent scope by 
		  <code class="ph codeph">keyref="a.product"</code>, 
		  <code class="ph codeph">keyref="b.product"</code>, or 
		  <code class="ph codeph">keyref="c.product"</code> 
		</p> 
		<p class="p">Because a child scope contributes its scope-qualified keys to its
		  parent scope, and that parent scope contributes 
		  <em class="ph i">its</em> scope-qualified keys to 
		  <em class="ph i">its</em> parent scope, it is possible to address the keys in any
		  descendant scope by using the scope-qualified key name. For example, consider a
		  key scope named "ancestorScope" that has a child scope named "parentScope"
		  which in turn has a child scope named "childScope". The scope "childScope"
		  defines a key named "keyName". To reference the key "keyName" from scope
		  "ancestorScope", specify the scope-qualified key name: 
		  <code class="ph codeph">keyref="parentScope.childScope.keyName"</code>. 
		</p> 
	 </section> 
	 <section class="section" id="concept_art_5ps_sr__keys-in-sibling-key-scope"><h4 class="title sectiontitle">Keys that are defined in sibling key scopes</h4> 
		 
		<p class="p">Because a parent key scope contains scope-qualified keys from all of
		  its child scopes, and a child scope inherits all of the key definitions
		  (including scope-qualified keys) from its parent scope, it is possible for a
		  child scope to reference its own scope-qualified keys, as well as those defined
		  by its sibling scopes. 
		</p> 
		<p class="p">For example, consider two sibling scopes, "scope1" and "scope2". Each
		  scope defines the key "productName". References to "productName" in each scope
		  resolve to the local definition. However, since each scope inherits the
		  scope-qualified keys that are available in their parent scope, either scope can
		  reference "scope1.productName" and "scope2.productName" to refer to the
		  scope-specific definitions for that key. 
		</p> 
	 </section> 
  </div>
</article><article class="topic concept nested2" aria-labelledby="ariaid-title10" lang="en-us" id="links-between-maps">
 <h3 class="title topictitle3" id="ariaid-title10"><span class="ph">Cross-deliverable addressing and linking</span></h3>
 
 <div class="body conbody"><p class="shortdesc">A map can use scoped keys to reference keys that are defined in a different root map.
        This cross-deliverable addressing can support the production of deliverables that contain
        working links to other deliverables.</p>
        
        <p class="p">When maps are referenced and the value of the
                <code class="keyword markupname xmlatt">@scope</code> attribute is set to "peer", the implications are that the two
            maps are managed in tandem, and that the author of the referencing map might have access
            to the referenced map. Adding a key scope to the reference indicates that the peer map
            should be treated as a separate deliverable for the purposes of linking.</p>
    
  <p class="p">The keys that are defined by the peer map belong to <span class="ph">any key scopes
                that are</span> declared on the <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> element that
            references that map. Such keys can be referenced from content in the referencing map by
            using scope-qualified key names. However, processors handle references to keys that are
            defined in peer maps differently from how they handle references to keys that are
            defined in submaps.</p>
  <p class="p">DITA processors are not required to resolve key references to peer maps. However, if all
            resources are available in the same processing or management context, processors have
            the potential to resolve key references to peer maps. There might be performance, scale,
            and user interface challenges in implementing such systems, but the ability to resolve
            any given reference is ensured when the source files are physically accessible.</p>
        
        
  <p class="p">Note the inverse implication; if the peer map is not available, then it is impossible to
            resolve the key reference. Processors that resolve key references to peer maps should
            provide appropriate messages when a reference to a peer map cannot be resolved.
            Depending on how DITA resources are authored, managed, and processed, references to peer
            maps might not be resolvable at certain points in the content life cycle.</p>
  <p class="p">The peer map might specify <code class="keyword markupname xmlatt">@keyscope</code> on its root element. In that case, the
                <code class="keyword markupname xmlatt">@keyscope</code> on the peer map is ignored for the purpose of resolving
            scoped key references from the referencing map. This avoids the need for processors to
            have access to the peer map in order to determine whether a given key definition comes
            from the peer map.</p>
        <div class="example non-normative" id="links-between-maps__example-root-declares-peer"><h4 class="title sectiontitle">Example: A root map that declares a peer map</h4><p class="non-normative-label">This section is non-normative.</p>
            
            <p class="p">Consider the DITA maps <span class="ph filepath">map-a.ditamap</span> and
                    <span class="ph filepath">map-b.ditamap</span>. Map A designates Map B as a peer map by
                using the following markup:</p>
            <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;title&gt;Map A&lt;/title&gt;
  &lt;topicref 
    scope="peer"
    format="ditamap"
    keyscope="map-b"
    href="../map-b/map-b.ditamap"
    processing-role="resource-only"
  /&gt;
  &lt;!-- ... --&gt;
&lt;/map&gt;</code></pre>
            <p class="p">In this example, <span class="ph filepath">map-b.ditamap</span> is not a submap of Map A; it is a
                peer map.</p>
        </div>
        <div class="example non-normative" id="links-between-maps__example-peer-keyscope"><h4 class="title sectiontitle">Example: Key resolution in a peer map that contains a <code class="keyword markupname xmlatt">@keyscope</code>
                attribute on the root element</h4><p class="non-normative-label">This section is non-normative.</p>
            
            <p class="p">Consider the map reference in map Map A:</p>
            <pre class="pre codeblock"><code>&lt;mapref 
  keyscope="scope-b"
  scope="peer"  
  href="map-b.ditamap"
/&gt; </code></pre>
            <p class="p">where <span class="ph filepath">map-b.ditamap</span> contains the following markup:</p>
            <pre class="pre codeblock"><code>&lt;map keyscope="product-x"&gt;
 &lt;!-- ... --&gt;
&lt;/map&gt;</code></pre>
            <p class="p">From the context of Map A, key references of the form
                    <span class="keyword">scope-b.somekey</span> are resolved to keys that are defined in the
                global scope of map B, but key references of the form
                    <span class="keyword">product-x.somekey</span> are not. The presence of a
                    <code class="keyword markupname xmlatt">@keyscope</code> attribute on the <code class="keyword markupname xmlelement">&lt;map&gt;</code> element
                in Map B has no effect. A key reference to the scope
                    <span class="keyword">scope-b.somekey</span> is equivalent to the unscoped reference
                    <span class="keyword">somekey</span> when processed in the context of Map B as the root
                map. In both cases, the presence of <code class="keyword markupname xmlatt">@keyscope</code> on the root element of
                Map B has no effect; in the first case it is explicitly ignored, and in the second
                case the key reference is within the scope <span class="keyword">product-x</span> and so does
                not need to be scope qualified.</p>
        </div>
 </div>
</article><article class="topic concept nested2" aria-labelledby="ariaid-title11" lang="en-us" id="processing-key-references">
    <h3 class="title topictitle3" id="ariaid-title11">Processing key references</h3>
    
    <div class="body conbody"><p class="shortdesc">Key references can resolve as links, as text, or as both. Within a map, they also can
        be used to create or supplement information on a topic reference. This topic covers
        information that is common to all key processing, regardless of how the key is
        used.</p>
        <section class="section" id="processing-key-references__processing-undefined-keys"><h4 class="title sectiontitle">Processing of undefined keys</h4>
            
            <p class="p">If both <code class="keyword markupname xmlatt">@keyref</code> and <code class="keyword markupname xmlatt">@href</code> attributes are specified on
                an element, the <code class="keyword markupname xmlatt">@href</code> value <dfn class="term RFC-2119">MUST</dfn>
                be used as a fallback address when the key name is undefined. If both
                    <code class="keyword markupname xmlatt">@conkeyref</code> and <code class="keyword markupname xmlatt">@conref</code> attributes are specified
                on an element, the <code class="keyword markupname xmlatt">@conref</code> value <dfn class="term RFC-2119">MUST</dfn> be used as a fallback address when the key name is undefined.</p>
        </section>
        <section class="section" id="processing-key-references__combining-attributes"><h4 class="title sectiontitle">Determining effective attributes on the key-referencing element</h4>
            
            <p class="p">The attributes that are common to the key-defining element and the key-referencing
element, other than the <code class="keyword markupname xmlatt">@keys</code>,<span class="ph">
<code class="keyword markupname xmlatt">@processing-role</code>,</span> and <code class="keyword markupname xmlatt">@id</code> attributes, are combined as for
content references, including the special processing for the <code class="keyword markupname xmlatt">@xml:lang</code>,
<code class="keyword markupname xmlatt">@dir</code>, and <code class="keyword markupname xmlatt">@translate</code> attributes.</p>
        </section>
        <section class="section" id="processing-key-references__keys-and-condproc"><h4 class="title sectiontitle">Keys and conditional processing</h4>
            
            <p class="p">The effective key definitions for a key space might be affected by conditional
                processing (filtering). Processors <dfn class="term RFC-2119">SHOULD</dfn>
                perform conditional processing before determining the effective key definitions.
                However, processors might determine effective key definitions before filtering.
                Consequently, different processors might produce different effective bindings for
                the same map when there are key definitions that might be filtered out based on
                their filtering attributes.</p>
            <div class="note note note_note non-normative"><span class="note__title">Note<span class="non-normative-label"> (non-normative)</span>:</span> <div class="note__body">In order to retain backwards compatibility with DITA 1.0 and 1.1, the
                specification does not mandate a processing order for different DITA features. This
                makes it technically possible to determine an effective key definition, resolve
                references to that key definition, and then filter out the definition. However, the
                preferred approach is to take conditional processing into account when resolving
                keys, so that key definitions which are excluded by processing are not used in
                resolving key references.</div></div>
        </section>
        <section class="section" id="processing-key-references__reusing-topic-across-scopes"><h4 class="title sectiontitle">Reusing a topic in multiple key scopes</h4>
            
            <p class="p">If a topic that contains key references is reused in multiple key scopes within a
                given root map such that its references resolve differently in each use context,
                processors <dfn class="term RFC-2119">MUST</dfn> produce multiple copies of the
                source topic in resolved output for each distinct set of effective key definitions
                that are referenced by the topic. </p>
            <p class="p">In such cases, authors can use <code class="keyword markupname xmlelement">&lt;resourceid&gt;</code> within topic
                references to specify distinct anchor components for each instance of the topic.</p>
            <p class="p"> with the <code class="keyword markupname xmlatt">@appid-role</code> attribute set to
                    <span class="keyword">deliverable-anchor</span> to specify different source URIs for each
                reference to a topic.</p>
        </section>
        <section class="section" id="processing-key-references__error-conditions"><h4 class="title sectiontitle">Error conditions</h4>
            
            <p class="p errorcondition">If a referencing element contains a key reference with
                an undefined key, it is processed as if there were no key reference, and the value
                of the <code class="keyword markupname xmlatt">@href</code> attribute is used as the reference. If the
                    <code class="keyword markupname xmlatt">@href</code> attribute is not specified, the element is not treated as
                a navigation link. <span class="error-statement" id="processing-key-references__d2353t1325" data-id=""></span>If it is an error for the element to be empty, an implementation
                    <dfn class="term RFC-2119">MAY</dfn> give an error message; it also <dfn class="term RFC-2119">MAY</dfn> recover from this error condition by leaving
                the key reference element empty.</p>
        </section>
    </div>
</article><article class="topic concept nested2" aria-labelledby="ariaid-title12" lang="en-us" id="processing_key_references">
    <h3 class="title topictitle3" id="ariaid-title12"><span class="ph">Processing key references for navigation links and images</span></h3>
    
    <div class="body conbody"><p class="shortdesc">Keys can be used to create or redirect links and cross references. Keys also can be
        used to address resources such as images or videos. This topic explains how to evaluate key
        references on links and cross references to determine a link target. </p>
        <p class="p">When a key definition is bound to a resource that is addressed by the
                <code class="keyword markupname xmlatt">@href</code> or <code class="keyword markupname xmlatt">@keyref</code> attributes, and does not specify
            "none" for the <code class="keyword markupname xmlatt">@linking</code> attribute, all references to that key definition
            become links to the bound resource. When a key definition is not bound to a resource or
            specifies "none" for the <code class="keyword markupname xmlatt">@linking</code> attribute, references to that key
            definition do not become links.</p>
        <p class="p">When a key definition has no <code class="keyword markupname xmlatt">@href</code> value and no <code class="keyword markupname xmlatt">@keyref</code>
            value, references to that key will not result in a link, even if they do contain an
                <code class="keyword markupname xmlatt">@href</code> attribute of their own. If the key definition also does not
            contain a <code class="keyword markupname xmlelement">&lt;topicmeta&gt;</code> subelement, empty elements that refer to
            the key (such as <code class="ph codeph">&lt;link keyref="a"/&gt;</code> or <code class="ph codeph">&lt;xref keyref="a"
                href="fallback.dita"/&gt;</code>) are <span class="ph">ignored</span>.</p>
        <p class="p">The <code class="keyword markupname xmlelement">&lt;object&gt;</code> element has an additional key-referencing attribute
            named <code class="keyword markupname xmlatt">@datakeyref</code>. Key names in this attribute are resolved using the
            same processing that is described for the normal <code class="keyword markupname xmlatt">@keyref</code> attribute.</p>
        
    </div>
</article><article class="topic concept nested2" aria-labelledby="ariaid-title13" lang="en-us" id="processing-keyref-on-topicref">
    <h3 class="title topictitle3" id="ariaid-title13">Processing key references on <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> elements</h3>
    
    <div class="body conbody"><p class="shortdesc">While <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> elements are used to define keys, they also
        can reference keys that are defined elsewhere. This topic explains how to evaluate key
        references on <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> elements and its
        specializations.</p>
        <dl class="dl">
            
                <dt class="dt dlterm">Determining the effective resource</dt>
                <dd class="dd">
                    <p class="p">For topic references that use the <code class="keyword markupname xmlatt">@keyref</code> attribute, the
                        effective resource bound to the <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> element is
                        determined by resolving all intermediate key references. Each key reference
                        is resolved either to a resource addressed directly by URI reference in an
                            <code class="keyword markupname xmlatt">@href</code> attribute, or to no resource. Processors <dfn class="term RFC-2119">MAY</dfn> impose reasonable limits on the number
                        of intermediate key references that they will resolve. Processors <dfn class="term RFC-2119">SHOULD</dfn> support at least three levels of
                        key references.</p>
                    <div class="note note note_note non-normative"><span class="note__title">Note<span class="non-normative-label"> (non-normative)</span>:</span> <div class="note__body">This rule applies to all topic references, including those that define
                        keys. The effective bound resource for a key definition that uses the
                            <code class="keyword markupname xmlatt">@keyref</code> attribute cannot be determined until the key
                        space has been constructed.</div></div>
                </dd>
            
            
                <dt class="dt dlterm">Combining metadata</dt>
                <dd class="dd">
                    <p class="p">Content from a key-defining element cascades to the key-referencing element
following the rules for combining metadata between maps and other maps and between maps and
topics.</p>
                    <p class="p">The combined attributes and content cascade from one map to another or from a
                        map to a topic, but this is controlled by existing rules for cascading,
                        which are not affected by the use of key references.</p>
                </dd>
            
        </dl>
        <p class="p"> If, in addition to the <code class="keyword markupname xmlatt">@keys</code> attribute, a key definition specifies a
                <code class="keyword markupname xmlatt">@keyref</code> attribute that can be resolved after the key resolution
            context for the key definition has been determined, the resources bound to the
            referenced key definition take precedence.</p>
    </div>
</article><article class="topic concept nested2" aria-labelledby="ariaid-title14" lang="en-us" id="unique_1645924002">
    <h3 class="title topictitle3" id="ariaid-title14">Processing key references to generate text or link text</h3>
    
    <div class="body conbody"><p class="shortdesc">Variable text can be specified by key definitions. Processors determine the effective
        text by retrieving the content of elements in a specific sequence.</p>
        <dl class="dl">
            
                <dt class="dt dlterm">Empty elements</dt>
                <dd class="dd">
                    <p class="p">Empty elements that specify a key reference might get their effective content
                        from the referenced key definitions. For the purpose of determining variable
                        text, <dfn class="term">empty elements</dfn> are defined as elements that meet the
                        following criteria:</p>
                    <ul class="ul" id="unique_1645924002__ul_ylq_w1w_bpb">
                        <li class="li">Have no text content, including white space</li>
                        <li class="li">Have no
                            sub-elements</li>
                        <li class="li">Have no attributes that would be used as text content</li>
                    </ul>
                </dd>
            
            
                <dt class="dt dlterm">Key definitions with child <code class="keyword markupname xmlelement">&lt;topicmeta&gt;</code> elements</dt>
                <dd class="dd">
                    <p class="p">When an empty element references a key definition that has a child
                            <code class="keyword markupname xmlelement">&lt;topicmeta&gt;</code> element, content from that
                            <code class="keyword markupname xmlelement">&lt;topicmeta&gt;</code> element is used to determine the
                        effective content of the referencing element. Effective content from the key
                        definition becomes the element content, with the following exceptions: </p>
                    <ul class="ul" id="unique_1645924002__ul_zlq_w1w_bpb">
                        <li class="li">For empty <code class="keyword markupname xmlelement">&lt;image&gt;</code> elements, the effective content
                            is used as alternate text. This is equivalent to creating an
                                <code class="keyword markupname xmlelement">&lt;alt&gt;</code> sub-element to hold that content.</li>
                        <li class="li">For empty <code class="keyword markupname xmlelement">&lt;link&gt;</code> elements, the effective content
                            is used as link text. This is equivalent to creating a
                                <code class="keyword markupname xmlelement">&lt;linktext&gt;</code> sub-element to hold that
                            content.</li>
                        <li class="li">For empty <code class="keyword markupname xmlelement">&lt;link&gt;</code> and
                                <code class="keyword markupname xmlelement">&lt;xref&gt;</code> elements, a key definition can provide
                            a short description in addition to the normal effective content. If the
                            key definition includes <code class="keyword markupname xmlelement">&lt;shortdesc&gt;</code> inside of
                                <code class="keyword markupname xmlelement">&lt;topicmeta&gt;</code>, the content of the
                                <code class="keyword markupname xmlelement">&lt;shortdesc&gt;</code> element also provides effective
                            content for a <code class="keyword markupname xmlelement">&lt;desc&gt;</code> sub-element.</li>
                        <li class="li">The <code class="keyword markupname xmlelement">&lt;longdescref&gt;</code> element is an empty element
                            with no effective content. Key definitions do not set effective text for
                            this element.</li>
                        <li class="li">The <code class="keyword markupname xmlelement">&lt;param&gt;</code> element does not have any effective
                            content, so key definitions do not result in effective content for
                                <code class="keyword markupname xmlelement">&lt;param&gt;</code> elements.</li>
                    </ul>
                    
                </dd>
            
            
                <dt class="dt dlterm">Processing rules</dt>
                <dd class="dd">
                    <div class="p">Processors <dfn class="term RFC-2119">MUST</dfn> resolve variable text
                        that is defined using keys by using the following sequence:<ol class="ol" id="unique_1645924002__ol_amq_w1w_bpb">
                            <li class="li">Effective text content is taken from the
                                    <code class="keyword markupname xmlelement">&lt;keytext&gt;</code> element.</li>
                            <li class="li">Effective text content is taken from the
                                    <code class="keyword markupname xmlelement">&lt;titlealt&gt;</code> element with
                                    <code class="keyword markupname xmlatt">@title-role</code> set to
                                <span class="keyword">linking</span>.</li>
                            <li class="li">Effective text content is taken from the
                                    <code class="keyword markupname xmlelement">&lt;titlealt&gt;</code> element with
                                    <code class="keyword markupname xmlatt">@title-role</code> set to
                                <span class="keyword">navigation</span>.</li>
                            <li class="li">Effective text content is taken from the
                                    <code class="keyword markupname xmlelement">&lt;titlealt&gt;</code> element with
                                    <code class="keyword markupname xmlatt">@title-role</code> set to a processor-recognized
                                value.</li>
                            <li class="li">Effective text content is taken from the title of the referenced
                                document, if available.</li>
                            <li class="li">Effective text content is determined by the processor.</li>
                        </ol></div>
                </dd>
            
            
                <dt class="dt dlterm">Generalization of effective content</dt>
                <dd class="dd">
                    <p class="p">When the effective content for a key reference element results in invalid
                        elements, those elements <dfn class="term RFC-2119">SHOULD</dfn> be
                        generalized to produce a valid result. </p>
                    <p class="p">For example, <code class="keyword markupname xmlelement">&lt;keytext&gt;</code> in the key definition might use
                        a domain specialization of <code class="keyword markupname xmlelement">&lt;keyword&gt;</code> that is not
                        valid in the key reference context, in which case the specialized element is
                        generalized to <code class="keyword markupname xmlelement">&lt;keyword&gt;</code>. If the generalized content
                        is also not valid, a text equivalent is used instead. For example,
                            <code class="keyword markupname xmlelement">&lt;keytext&gt;</code> might include
                            <code class="keyword markupname xmlelement">&lt;ph&gt;</code> or a specialized <code class="keyword markupname xmlelement">&lt;ph&gt;</code>
                        in the key definition, but neither of those are valid as the effective
                        content for a <code class="keyword markupname xmlelement">&lt;keyword&gt;</code>. In that case, the text
                        content of the <code class="keyword markupname xmlelement">&lt;ph&gt;</code> is used.</p>
                </dd>
            
        </dl>
    </div>
</article><article class="topic concept nested2 non-normative" aria-labelledby="ariaid-title15" lang="en-us" id="examples_of_keys">
    <h3 class="title topictitle3" id="ariaid-title15">Examples of keys</h3>
    <div class="body"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">This section of the specification contains examples and scenarios. They illustrate a
        wide variety of ways that keys can be used.</p></div>
<article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title16" lang="en-us" id="concept_ahg_25y_lp">
 <h4 class="title topictitle4" id="ariaid-title16">Examples: Key definition</h4>
 
 <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">The <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> element, and any specialization of
      <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> that allows the <code class="keyword markupname xmlatt">@keys</code> attribute, can be used
    to define keys.</p>
  <p class="p">In the following example, a <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> element is used to define a key;
   the <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> element also contributes to the navigation structure.</p>
  <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;!--... --&gt;
  &lt;topicref keys="apple-definition" href="apple-gloss-en-US.dita" /&gt;
  &lt;!--... --&gt;
&lt;/map&gt;</code></pre>
  <p class="p">The presence of the <code class="keyword markupname xmlatt">@keys</code> attribute does not affect how the
        <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> element is processed.</p>
  <p class="p">In the following example, a <code class="keyword markupname xmlelement">&lt;keydef&gt;</code> element is used to define a
   key.</p>
  <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;!--... --&gt;
  &lt;keydef keys="apple-definition" href="apple-gloss-en-US.dita"/&gt;
  &lt;!--... --&gt;
&lt;/map&gt;</code></pre>
  <p class="p">Because the <code class="keyword markupname xmlelement">&lt;keydef&gt;</code> element sets the default value of the
        <code class="keyword markupname xmlatt">@processing-role</code> attribute to "resource-only", the key definition does not
      contribute to the map navigation structure; it only serves as a key definition for <span class="ph">the key name</span> "apple-definition".</p>
 </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title17" lang="en-us" id="concept_g5x_y2z_lp">
 <h4 class="title topictitle4" id="ariaid-title17">Examples: Key definitions for variable text</h4>
 
 <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">Key definitions can be used to store variable text, such as product names and
  user-interface labels. Depending on the key definition, the rendered output might have a link to a
  related resource.</p>
    
  <p class="p">In the following example, a "product-name" key is defined. The key definition contains a child
        <code class="keyword markupname xmlelement">&lt;keyword&gt;</code> element nested within a
      <code class="keyword markupname xmlelement">&lt;keydef&gt;</code>element.</p>
  <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;keydef keys="product-name"&gt;
    &lt;topicmeta&gt;
     &lt;keywords&gt;
       <strong class="ph b">&lt;keyword&gt;Thing-O-Matic&lt;/keyword&gt;</strong>
     &lt;/keywords&gt;
    &lt;/topicmeta&gt;
  &lt;/keydef&gt;
&lt;/map&gt;</code></pre>
  <div class="p">A topic can reference the "product-name" key by using the following markup:
      <pre class="pre codeblock"><code>&lt;topic id="topicid"&gt;
  &lt;title&gt;...&lt;/title&gt;
  &lt;body&gt;
    &lt;p&gt;&lt;keyword keyref="product-name"/&gt; is a product designed to ...&lt;/p&gt;
  &lt;/body&gt;
&lt;/topic&gt;</code></pre></div>
  <p class="p">When processed, the output contains the text "Thing-O-Matic is a product designed to ".</p>
  <p class="p">In the following example, the key definition contains both a reference to a resource and
   variable text.</p>
  <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;keydef keys="product-name" href="thing-o-matic.dita"&gt;
    &lt;topicmeta&gt;
     &lt;keywords&gt;
       <strong class="ph b">&lt;keyword&gt;Thing-O-Matic&lt;/keyword&gt;</strong>
     &lt;/keywords&gt;
    &lt;/topicmeta&gt;
  &lt;/keydef&gt;
&lt;/map&gt;</code></pre>
  <p class="p">When processed using the key reference from the first example, the output contains the
      "Thing-O-Matic is a product designed to  " text. The phrase "Thing-O-Matic" also is a link to
      the <span class="ph filepath">thing-o-matic.dita</span> topic.</p>
 </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title18" lang="en-us" id="concept_cmm_rwy_lp">
 <h4 class="title topictitle4" id="ariaid-title18">Example: Duplicate key definitions within a single map</h4>
 
 <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc"><span class="ph">In this scenario, a DITA map contains duplicate key
      definitions.</span> How a processor finds the effective key definition depends on document order
      <span class="ph">and the effect of filtering applied to the key
    definitions.</span></p>
    
  <p class="p">In the following example, a map contains two definitions for the key "load-toner":</p>
  <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;!--... --&gt;
  &lt;keydef keys="load-toner" href="model-1235-load-toner-proc.dita"/&gt;
  &lt;keydef keys="load-toner" href="model-4545-load-toner-proc.dita"
  /&gt;
  &lt;!--... --&gt;
&lt;/map&gt;</code></pre>
  <p class="p">In this example, only the first key definition (in document order) of the "load-toner" key is
      effective. All references to the key within the scope of the map resolve to the topic
        <span class="ph filepath">model-1235-load-toner-proc.dita</span>.</p>
  <p class="p">In the following example, a map contains two definitions for the "file-chooser-dialog" key;
   each key definition specifies a different value for the <code class="keyword markupname xmlatt">@platform</code> attribute.</p>
  <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;!--... --&gt;
  &lt;keydef keys="file-chooser-dialog" href="file-chooser-osx.dita" <strong class="ph b">platform="osx"</strong>/&gt;
  &lt;keydef keys="file-chooser-dialog" href="file-chooser-win7.dita" <strong class="ph b">platform="windows7"</strong>/&gt;
  &lt;!--... --&gt;
&lt;/map&gt;</code></pre>
  <p class="p">In this case, the effective key definition is determined not only by the order in which the
      definitions occur, but also by whether the active value of the platform condition is
        <span class="keyword">osx</span> or <span class="keyword">windows7</span>. Both key definitions are
        <em class="ph i">potentially</em> effective because they have distinct values for the conditional
      attribute. Note that if no active value is specified for the <code class="keyword markupname xmlatt">@platform</code>
      attribute at processing time, then both of the key definitions are present and so the first
      one in document order is the effective definition. </p>
  <div class="p">If the DITAVAL settings are defined so that both <span class="keyword">osx</span> and
        <span class="keyword">windows7</span> values for the <code class="keyword markupname xmlatt">@platform</code> attribute are excluded,
      then neither definition is effective and the key is undefined. That case can be avoided by
      specifying an unconditional key definition after any conditional key definitions, for
      example:<pre class="pre codeblock"><code>&lt;map&gt;
  &lt;!--... --&gt;
  &lt;keydef keys="file-chooser-dialog" href="file-chooser-osx.dita" platform="osx"/&gt;
  &lt;keydef keys="file-chooser-dialog" href="file-chooser-win7.dita" platform="windows7"/&gt;
  <strong class="ph b">&lt;keydef keys="file-chooser-dialog" href="file-chooser-generic.dita"/&gt;</strong>
  &lt;!--... --&gt;
&lt;/map&gt;</code></pre></div>
  <p class="p">If the above map is processed with both <span class="keyword">osx</span> and <span class="keyword">windows7</span>
      values for the <code class="keyword markupname xmlatt">@platform</code> attribute excluded, then the effective key definition
      for "file-chooser-dialog" is the <span class="ph filepath">file-chooser-generic.dita</span> resource.</p>
 </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title19" lang="en-us" id="concept_zpw_51z_lp">
 <h4 class="title topictitle4" id="ariaid-title19">Example: Duplicate key definitions across multiple maps</h4>
 
 <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">In this scenario, the root map contains references to two submaps,
    each of which defines the same key. The effective key definition depends upon the document order
    of the direct URI references to the maps.</p>
  <p class="p">In the following example, a root map contains a key definition for the <span class="ph">key
    "toner-specs" and references to two submaps.</span></p>
  <pre class="pre codeblock"><code>&lt;map&gt;
  <strong class="ph b">&lt;keydef keys="toner-specs" href="toner-type-a-specs.dita"/&gt;</strong>
  &lt;mapref href="submap-01.ditamap"/&gt;
  &lt;mapref href="submap-02.ditamap"/&gt;
&lt;/map&gt;
</code></pre>
  <p class="p">The first submap, <span class="ph filepath">submap-01.ditamap</span>, contains definitions for the <span class="ph">keys "toner-specs" and "toner-handling":</span></p>
  <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;keydef keys="toner-specs" href="toner-type-b-specs.dita"/&gt;
  <strong class="ph b">&lt;keydef keys="toner-handling" href="toner-type-b-handling.dita"/&gt;</strong>
&lt;/map&gt;</code></pre>
  <p class="p">The second submap, <span class="ph filepath">submap-02.ditamap</span>, contains definitions for the <span class="ph">keys "toner-specs", "toner-handling", and "toner-disposal":</span></p>
  <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;keydef keys="toner-specs" href="toner-type-c-specs.dita"/&gt;
  &lt;keydef keys="toner-handling" href="toner-type-c-handling.dita"/&gt;
  <strong class="ph b">&lt;keydef keys="toner-disposal" href="toner-type-c-disposal.dita"/&gt;</strong>
&lt;/map&gt;</code></pre>
  <p class="p">For this example, the effective key definitions are listed in the following table.</p>
  <table class="simpletable frame-topbot" id="concept_zpw_51z_lp__simpletable_a459d096-5695-474b-9e7f-3797b458437c"><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr class="sthead">
    <th class="stentry" scope="col" id="concept_zpw_51z_lp__simpletable_a459d096-5695-474b-9e7f-3797b458437c__stentry__1">Key</th>
    <th class="stentry" scope="col" id="concept_zpw_51z_lp__simpletable_a459d096-5695-474b-9e7f-3797b458437c__stentry__2">Bound resource</th>
   </tr></thead><tbody><tr class="strow">
    <td class="stentry" headers="concept_zpw_51z_lp__simpletable_a459d096-5695-474b-9e7f-3797b458437c__stentry__1">toner-specs</td>
    <td class="stentry" headers="concept_zpw_51z_lp__simpletable_a459d096-5695-474b-9e7f-3797b458437c__stentry__2"><span class="ph filepath">toner-type-a-specs.dita</span></td>
   </tr><tr class="strow">
    <td class="stentry" headers="concept_zpw_51z_lp__simpletable_a459d096-5695-474b-9e7f-3797b458437c__stentry__1">toner-handling</td>
    <td class="stentry" headers="concept_zpw_51z_lp__simpletable_a459d096-5695-474b-9e7f-3797b458437c__stentry__2"><span class="ph filepath">toner-type-b-handling.dita</span></td>
   </tr><tr class="strow">
    <td class="stentry" headers="concept_zpw_51z_lp__simpletable_a459d096-5695-474b-9e7f-3797b458437c__stentry__1">toner-disposal</td>
    <td class="stentry" headers="concept_zpw_51z_lp__simpletable_a459d096-5695-474b-9e7f-3797b458437c__stentry__2"><span class="ph filepath">toner-type-c-disposal.dita</span></td>
   </tr></tbody></table>
  <p class="p">The key definition for "toner-specs" in the root map is effective, because it is the first
      encountered in a breadth-first traversal of the root map. The key definition for
      "toner-handling" in <span class="ph filepath">submap-01.ditamap</span> is effective, because submap-01 is
      included before submap-02 and so comes first in a breadth-first traversal of the submaps. The
      key definition for "toner-disposal" is effective because it is the only definition of the
      key.</p>
 </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title20" lang="en-us" id="unique_123453341">
 <h4 class="title topictitle4" id="ariaid-title20">Example: Key definition with key reference</h4>
 
 <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">When a key definition also specifies a key reference, the key reference also must be
    resolved in order to determine the effective resources that are bound to that key
    definition.</p>
    <p class="p">In the following example, a <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> element references the key
      "widget". The definition for "widget" in turn references the key "mainProduct".</p>
    <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;topicref keyref="widget" id="example"/&gt;
  &lt;keydef keys="widget" href="widgetInfo.dita" scope="local" format="dita" rev="v1r2"
          keyref="mainProduct"&gt;
    &lt;topicmeta&gt;&lt;navtitle&gt;Information about Widget&lt;/navtitle&gt;&lt;/topicmeta&gt;
  &lt;/keydef&gt;
  &lt;keydef keys="mainProduct" href="http://example.com/productPage" scope="external" format="html"
          product="prodCode" audience="sysadmin"&gt;
    &lt;topicmeta&gt;&lt;navtitle&gt;Generic product page&lt;/navtitle&gt;&lt;/topicmeta&gt;
  &lt;/keydef&gt;
&lt;/map&gt;
  </code></pre>
    <p class="p">For this example, the key reference to "widget" pulls resources from that key definition,
      which in turn pulls resources from "mainProduct".</p>
    <p class="p">The resources from the key definitions are combined as follows:</p>
    <ul class="ul">
      <li class="li">The metadata resources from "mainProduct" are combined with the resources already
        specified on the "widget" key definition, resulting in the addition of
          <code class="keyword markupname xmlatt">@product</code> and <code class="keyword markupname xmlatt">@audience</code> values.</li>
      <li class="li">The navigation title on the "widget" key definition overrides those on the "mainProduct"
        key definition.</li>
      <li class="li">The <code class="keyword markupname xmlatt">@href</code>, <code class="keyword markupname xmlatt">@scope</code>, and <code class="keyword markupname xmlatt">@format</code> attributes
        on the "mainProduct" key definition override those on "widget".</li>
    </ul>
    <p class="p"> Thus after key references are resolved, the original <code class="keyword markupname xmlelement">&lt;topicref&gt;</code>
      element is equivalent to the following:</p>
    <pre class="pre codeblock"><code>&lt;topicref id="example"
          href="http://example.com/productPage" scope="external" format="html" 
          rev="v1r2"
          product="prodCode" audience="sysadmin"&gt;
   &lt;topicmeta&gt;&lt;navtitle&gt;Information about Widget&lt;/navtitle&gt;&lt;/topicmeta&gt;
&lt;/topicref&gt;</code></pre>
  </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title21" lang="en-us" id="concept_qz4_35z_lp">
 <h4 class="title topictitle4" id="ariaid-title21">Example: Link redirection</h4>
 
 <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">This scenario outlines how different authors can redirect links to a common topic by
    using key definitions. <span class="ph">This could apply to
        <code class="keyword markupname xmlelement">&lt;xref&gt;</code>, <code class="keyword markupname xmlelement">&lt;link&gt;</code>, or any elements (such as
        <code class="keyword markupname xmlelement">&lt;keyword&gt;</code> or <code class="keyword markupname xmlelement">&lt;term&gt;</code>) that become navigation
      links.</span></p>
  <p class="p">A company wants to use a common DITA topic for information about recycling:
    <span class="ph filepath">recycling.dita</span>. However, the topic contains a cross-reference to a topic
   that needs to be unique for each product line; each such topic contains product-specific
   URLs.</p>
  <ol class="ol">
   <li class="li">
    <p class="p">The editing team creates a <span class="ph filepath">recycling.dita</span> topic that includes a
     cross-reference to the product-specific topic. The cross reference is implemented using a key
     reference:</p>
    <pre class="pre codeblock"><code>&lt;xref keyref="product-recycling-info" href="generic-recycling-info.dita"/&gt;</code></pre>
    <p class="p">The value of the <code class="keyword markupname xmlatt">@href</code> attribute provides a fallback in the event that a
     product team forgets to include a key definition for "product-recycling-info".</p>
   </li>
   <li class="li">
    <p class="p">Each product documentation group creates a unique key definition for
     "product-recycling-info". Each group authors the key definition in a DITA map, for example:</p>
    <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;!-- ... --&gt;
  &lt;keydef keys="product-recycling-info" href="acme-server-recycling.dita"/&gt;
  &lt;!-- ... --&gt;
&lt;/map&gt;</code></pre>
    <p class="p">Each team can use the <span class="ph filepath">recycling.dita</span> topic, and the cross reference in
     the topic resolves differently for each team.</p>
   </li>
   <li class="li">
    <p class="p">A year later, there is an acquisition. The newly-acquired team wants to reuse Acme's common
     material, but it needs to direct its users to an external Web site that lists the URLs, rather
     than a topic in the product documentation. Their key definition looks like the following:</p>
    <pre class="pre codeblock"><code>&lt;topicref  keys="product-recycling-info" 
                  href="http://acme.example.com/server/recycling" 
                  scope="external" format="html"/&gt;
 </code></pre>
    <p class="p">When newly-acquired team uses the <span class="ph filepath">recycling.dita</span> topic, it resolves to
     the external Web site; however for all other teams, the cross reference in the topic continues
     to resolves to their product-specific topic.</p>
   </li>
   <li class="li">
    <p class="p">A new product team is formed, and the team forgets to include a key definition for
     "product-recycling-info" in one of their root maps. Because the cross reference in the
      <span class="ph filepath">recycling.dita</span> topic contains a value for the <code class="keyword markupname xmlatt">@href</code>
     attribute, the link falls back to <span class="ph filepath">generic-recycling-info.dita</span>, thus
     avoiding a broken cross reference in the output.</p>
   </li>
  </ol>
 </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title22" lang="en-us" id="concept_gtj_df1_mp">
 <h4 class="title topictitle4" id="ariaid-title22">Example: Link modification or removal</h4>
 
 <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">This scenario outlines how different authors can effectively remove or modify a
      <code class="keyword markupname xmlelement">&lt;link&gt;</code> element in a shared topic.</p>
  <p class="p">A company wants to use a shared topic for information about customer support. For most
      products, the shared topic includes a link to a topic about extended warranties. But a small
      number of products do not offer extended warranties.</p>
  <ol class="ol">
   <li class="li">
    <p class="p">Team one creates the shared topic: <span class="ph filepath">customer-support.dita</span>. The topic
     contains the following mark-up:</p>
    <pre class="pre codeblock"><code> &lt;related-links&gt;
  &lt;link keyref="extended-warranties" href="common/extended-warranties.dita"/&gt;
 &lt;/related-links&gt;</code></pre>
   </li>
   <li class="li">
    <p class="p">The teams that need the link to the topic about extended warranties can reference the
      <span class="ph filepath">customer-support.dita</span> topic in their DITA maps. When processed, the
     related link in the topic resolves to the <span class="ph filepath">common/extended-warranties.dita</span>
     topic.</p>
   </li>
   <li class="li">
    <p class="p">The teams that do not want the related link to the topic about extended warranties can
          include a key definition in their DITA map that does not include an <code class="keyword markupname xmlatt">@href</code>
          attribute, for example: </p>
    <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;!-- ... --&gt;
  &lt;keydef keys="extended-warranties"/&gt;
  &lt;!-- ... --&gt;
&lt;/map&gt;</code></pre>
    <p class="p">When processed, the related link in the topic is not rendered.</p>
   </li>
   <li class="li">
    <p class="p">Yet another team wants to simply have a paragraph about extended warranties printed. They
     define the key definition for "extended-warranties" as follows:</p>
    <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;!-- ... --&gt;
  &lt;keydef keys="extended-warranties"&gt;
    &lt;topicmeta&gt;
      &lt;keytext&gt;This product does not offer extended warranties.&lt;/keytext&gt;
    &lt;/topicmeta&gt;
  &lt;/keydef&gt;
  &lt;!-- ... --&gt;
&lt;/map&gt;</code></pre>
    <p class="p">When this team renders their content, there is no hyperlink in the output, just the text
          "This product does not offer extended warranties" statement.</p>
   </li>
  </ol>
 </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title23" lang="en-us" id="concept_fwk_bhf_mp">
 <h4 class="title topictitle4" id="ariaid-title23">Example: Links from <code class="keyword markupname xmlelement">&lt;term&gt;</code> or <code class="keyword markupname xmlelement">&lt;keyword&gt;</code>
  elements</h4>
 
 <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">The <code class="keyword markupname xmlatt">@keyref</code> attribute enables authors to specify that references to
  keywords or terms in a DITA topic can be rendered as a link to an associated resource.</p>
  <p class="p">In this scenario, a company with well-developed glossary wants to ensure that instances of a
   term that is defined in the glossary always include a link to the glossary topic.</p>
  <ol class="ol">
   <li class="li">
    <p class="p">An information architect adds values for the <code class="keyword markupname xmlatt">@keys</code> attribute to all the of
     the <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> elements that are in the DITA map for the glossary, for
     example:</p>
    <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;title&gt;Company-wide glossary&lt;/title&gt;
  &lt;topicref keys="term-1" href="term-1.dita"/&gt;
  &lt;topicref keys="term-2" href="term-2.dita"/&gt;
  &lt;topicref keys="term-3" href="term-3.dita"/&gt;
  &lt;topicref keys="term-4" href="term-4.dita"/&gt;
&lt;/map&gt;</code></pre>
   </li>
   <li class="li">
    <p class="p">When authors refer to a term in a topic, they use the following mark-up:</p>
    <pre class="pre codeblock"><code>&lt;term keyref="term-1"/&gt;</code></pre>
    <p class="p">When the <code class="keyword markupname xmlelement">&lt;term&gt;</code> element is rendered, the content <span class="ph">is provided</span>
     by the <code class="keyword markupname xmlelement">&lt;title&gt;</code> element of the glossary topic. The
      <code class="keyword markupname xmlelement">&lt;term&gt;</code> element <span class="ph">also is rendered as</span> a
     link to the glossary topic.</p>
   </li>
  </ol>
 </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title24" lang="en-us" id="concept_cw3_cl1_mp">
 <h4 class="title topictitle4" id="ariaid-title24">Example: conref redirection</h4>
 
 <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">The <code class="keyword markupname xmlatt">@conkeyref</code> attribute enables authors to share DITA topics that reuse
    content. It also enables <span class="ph">map authors</span> to specify different key
    definitions for common keys. </p>
  <p class="p">In this scenario, Acme produces content for a product that is also resold through a business
      partner. When the DITA content is published for the partner, several items must be different,
      including the following:</p>
  <ul class="ul">
   <li class="li">Product names</li>
   <li class="li">Standard notes that contain admonitions</li>
  </ul>
  <p class="p">Simply using the <code class="keyword markupname xmlatt">@conref</code> attribute would not be possible for teams that use a
      component content management system where every DITA topic is addressed by a globally-unique
      identifier (GUID).</p>
  <ol class="ol">
   <li class="li">
    <p class="p">Authors reference the reusable content in their topics by using the
      <code class="keyword markupname xmlatt">@conkeyref</code> attribute, for example:</p>
    <pre class="pre codeblock"><code>&lt;task id="reusable-product-content"&gt;
  &lt;title&gt;&lt;keyword conkeyref="reuse/product-name"/&gt; prerequisites&lt;/title&gt;
  &lt;taskbody&gt;
    &lt;prereq&gt;&lt;note conkeyref="reuse/warning-1"/&gt;&lt;/prereq&gt;
    &lt;!-- ... --&gt;
  &lt;/taskbody&gt;
&lt;/task&gt;
</code></pre>
   </li>
   <li class="li">
        <p class="p">Authors create two different topics; one topic contains elements appropriate for Acme,
          and the other topic contains elements appropriate for the partner. Note that each reuse
          topic must use the <span class="ph">same element types (or compatible
            specializations)</span> and values for the <code class="keyword markupname xmlatt">@id</code> attribute. For example, the
          following reuse file is appropriate for use by Acme:</p>
        <pre class="pre codeblock"><code>&lt;topic id="acme-reuse"&gt;
  &lt;title&gt;Reuse topic for Acme&lt;/title&gt;
  &lt;body&gt;
    &lt;note <strong class="ph b">id="warning-1"</strong>&gt;Admonitions for Acme&lt;/note&gt;
    &lt;p&gt;&lt;keyword <strong class="ph b">id="product-name"</strong>&gt;Acme product name&lt;/keyword&gt;&lt;/p&gt;
    &lt;!-- ... --&gt;
  &lt;/body&gt;
&lt;/topic&gt;</code></pre>
        <p class="p">The following reuse file is appropriate for use by the OEM partner:</p>
        <pre class="pre codeblock"><code>&lt;topic id="oem-reuse"&gt;
  &lt;title&gt;Reuse topic for OEM partner&lt;/title&gt;
  &lt;body&gt;
    &lt;note <strong class="ph b">id="warning-1"</strong>&gt;Admonitions for partner&lt;/note&gt;
    &lt;p&gt;&lt;keyword <strong class="ph b">id="product-name"</strong>&gt;OEM product name&lt;/keyword&gt;&lt;/p&gt;
    &lt;!-- ... --&gt;
  &lt;/body&gt;
&lt;/topic&gt;</code></pre>
      </li>
   <li class="li">
    <p class="p">The two versions of the DITA maps each contain different key definitions for the key name
          "reuse". (This associates a key with the topic that contains the appropriate reusable
          elements.) For example:</p>
    <figure class="fig fignone"><figcaption><span class="fig--title-label">Figure 4. </span>DITA map for Acme</figcaption>
     
     <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;!-- ... --&gt;
  &lt;keydef keys="reuse" href="acme-reuse.dita"/&gt;
  &lt;!-- ... --&gt;
&lt;/map&gt;</code></pre>
    </figure>
    <figure class="fig fignone"><figcaption><span class="fig--title-label">Figure 5. </span>DITA map for OEM partner</figcaption>
     
     <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;!-- ... --&gt;
  &lt;keydef keys="reuse" href="oem-reuse.dita"/&gt;
  &lt;!-- ... --&gt;
&lt;/map&gt;</code></pre>
    </figure>
   </li>
  </ol>
  <p class="p">When each of the DITA maps is published, the elements that are referenced by
        <code class="keyword markupname xmlatt">@conkeyref</code> will use the reuse topic that is referenced by the
        <code class="keyword markupname xmlelement">&lt;keydef&gt;</code> element in the map. The product names and warnings will be
      different in the output.</p>
 </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title25" lang="en-us" id="concept_yj5_d4f_mp">
 <h4 class="title topictitle4" id="ariaid-title25">Example: Keys and collaboration</h4>
 
 <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">Keys enable authors to collaborate and work with evolving content with a minimum of time
    spent reworking topic references.</p>
  <p class="p">In this scenario, authors collaborate on a publication that includes content for a product that
   is in the early stages of development. The company documentation is highly-structured and uses
   the same organization for all publications: "Introduction," "Example," and "Reference."</p>
  <ol class="ol">
   <li class="li">
    <p class="p">Author one creates a submap for the new product information. She knows the structure that the
     final content will have, but she does not want to create empty topics for information that is
     not yet available. She decides to initially author what content is available in a single topic.
     When more content is available, she'll create additional topics. Her DITA map looks like the
     following:</p>
    <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;title&gt;New product content&lt;/title&gt;
  &lt;topicref keys="1-overview 1-intro 1-example 1-reference" href="1-overview.dita"/&gt;
&lt;/map&gt;</code></pre>
   </li>
   <li class="li">
    <p class="p">Author two knows that he needs to add a <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> to the "Example"
          topic that will eventually be authored by author one. He references the not-yet-authored
          topic by key reference:</p>
    <pre class="pre codeblock"><code>&lt;topicref keyref="1-example"/&gt;</code></pre>
    <p class="p">His topic reference initially resolves to the <span class="ph filepath">1-overview.dita</span> topic.</p>
   </li>
   <li class="li">
    <p class="p">Author one finally gets the information that she was waiting on. She creates additional
     topics and modifies her DITA map as follows:</p>
    <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;title&gt;New product content&lt;/title&gt;
  &lt;topicref keys="1-overview" href="1-overview.dita"&gt;
    &lt;topicref keys="1-intro" href="1-intro.dita"/&gt;
    &lt;topicref keys="1-example" href="1-example.dita"/&gt;
    &lt;topicref keys="1-reference" href="1-reference.dita"/&gt;
  &lt;/topicref&gt;
&lt;/map&gt;</code></pre>
    <p class="p">Without needing to make any changes to the content, author two's topic reference now resolves
     to the <span class="ph filepath">1-example.dita</span> topic.</p>
   </li>
  </ol>
 </div>
</article></article><article class="topic concept nested2 non-normative" aria-labelledby="ariaid-title26" id="examples-of-scoped-keys">
    <h3 class="title topictitle3" id="ariaid-title26">Examples of scoped keys</h3>
    <div class="body"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">This section of the specification contains examples and scenarios. They illustrate
        how scoped keys can be used.</p></div>
<article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title27" lang="en-us" id="concept_b1c_mn1_mp">
 <h4 class="title topictitle4" id="ariaid-title27">Example: Scoped key definitions for variable text</h4>
 
 <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">Scoped key definitions can be used for variable text. This enables you to use the same
    DITA topic multiple times in a DITA map, and in each instance the variable text can resolve
    differently.</p>
    <p class="p">The Acme Tractor Company produces two models of tractor: X and Y. Their product manual
      contains sets of instructions for each model; until now, the maintenance procedures have been
      different for each model. Now, the product manual needs to add instructions for changing the
      oil, and the procedure is identical for both model X and model Y. While most maintenance
      procedures are different for each model, the instructions for changing the oil are identical
      for both model X and model Y. The company policies call for including the specific model
      number in each topic, so a generic topic that could be used for both models is not permitted.
      Scoped keys can solve this problem.</p>
  <ol class="ol">
   <li class="li">
        <p class="p">The authoring team creates the new <span class="ph filepath">changing-the-oil.dita</span>. The new
          topic uses the following markup to reference the product model:</p>
        <pre class="pre codeblock"><code>&lt;keyword keyref="model"/&gt;</code></pre>
      </li>
   <li class="li">
    <p class="p">The information architect examines the root map for the manual, and decides how to define key
          scopes. Originally, the map looked like the following:</p>
    <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;!-- Model X: Maintenance procedures --&gt;
  &lt;topicref href="model-x-procedures.dita"&gt;
    &lt;topicref href="model-x/replacing-a-tire.dita"/&gt;
    &lt;topicref href="model-x/adding-fluid.dita"/&gt;
  &lt;/topicref&gt;

&lt;!-- Model Y: Maintenance procedures --&gt;
  &lt;topicref href="model-y-procedures.dita"&gt;
    &lt;topicref href="model-y/replacing-a-tire.dita"/&gt;
    &lt;topicref href="model-y/adding-fluid.dita"/&gt;
  &lt;/topicref&gt;
&lt;/map&gt;</code></pre>
   </li>
   <li class="li">
    <p class="p">The information architect wraps each set of procedures in a
      <code class="keyword markupname xmlelement">&lt;topicgroup&gt;</code> element and sets the <code class="keyword markupname xmlatt">@keyscope</code>
     attribute.</p>
    <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;!-- Model X: Maintenance procedures --&gt;
  &lt;topicgroup <strong class="ph b">keyscope="model-x"</strong>&gt;
    &lt;topicref href="model-x-procedures.dita"&gt;
      &lt;topicref href="model-x/replacing-a-tire.dita"/&gt;
      &lt;topicref href="model-x/adding-fluid.dita"/&gt;
    &lt;/topicref&gt;
  &lt;/topicgroup&gt;

&lt;!-- Model Y: Maintenance procedures --&gt;
  &lt;topicgroup <strong class="ph b">keyscope="model-y"</strong>&gt;
    &lt;topicref href="model-y-procedures.dita"&gt;
      &lt;topicref href="model-y/replacing-a-tire.dita"/&gt;
      &lt;topicref href="model-y/adding-fluid.dita"/&gt;
    &lt;/topicref&gt;
  &lt;/topicgroup&gt;
&lt;/map&gt;</code></pre>
    <p class="p">This defines the key scopes for each set of procedures.</p>
   </li>
   <li class="li">
    <p class="p">The information architect then adds key definitions to each set of procedures, as well as a
     reference to the <span class="ph filepath">changing-the-oil.dita</span> topic.</p>
    <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;!-- Model X: Maintenance procedures --&gt;
  &lt;topicgroup keyscope="model-x"&gt;
    <strong class="ph b">&lt;keydef keys="model"&gt;
      &lt;topicmeta&gt;
        &lt;keytext&gt;X&lt;/keytext&gt;
      &lt;/topicmeta&gt;
    &lt;/keydef&gt;</strong>
    &lt;topicref href="model-x-procedures.dita"&gt;
      &lt;topicref href="model-x/replacing-a-tire.dita"/&gt;
      &lt;topicref href="model-x/adding-fluid.dita"/&gt;
      <strong class="ph b">&lt;topicref href="common/changing-the-oil.dita"/&gt;</strong>
    &lt;/topicref&gt;
  &lt;/topicgroup&gt;

&lt;!-- Model Y: Maintenance procedures --&gt;
  &lt;topicgroup keyscope="model-y"&gt;
    <strong class="ph b">&lt;keydef keys="model"&gt;
      &lt;topicmeta&gt;
        &lt;keytext&gt;Y&lt;/keytext&gt;
      &lt;/topicmeta&gt;
    &lt;/keydef&gt;</strong>
    &lt;topicref href="model-y-procedures.dita"&gt;
      &lt;topicref href="model-y/replacing-a-tire.dita"/&gt;
      &lt;topicref href="model-y/adding-fluid.dita"/&gt;
      <strong class="ph b">&lt;topicref href="common/changing-the-oil.dita"/&gt;</strong>
    &lt;/topicref&gt;
  &lt;/topicgroup&gt;
&lt;/map&gt;</code></pre>
    <p class="p">When the DITA map is processed, the <span class="ph filepath">changing-the-oil.dita</span> topic is
          rendered twice. The model variable is rendered differently in each instance, using the
          text as specified in the scoped key definition. <span class="ph">Without key scopes, the first key
            definition would win, and "model "X" would be used in all topics.</span></p>
   </li>
  </ol>
 </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title28" lang="en-us" id="concept_zms_tw1_mp">
 <h4 class="title topictitle4" id="ariaid-title28">Example: References to scoped keys</h4>
 
 <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">You can address scoped keys from outside the key scope in which the keys are
  defined.</p>
  <pre class="pre codeblock"><code>&lt;map xml:lang="en"&gt;
  &lt;title&gt;Examples of scoped key references&lt;/title&gt;

  &lt;!-- Key scope #1 --&gt;
  &lt;topicgroup keyscope="scope-1"&gt;
    <strong class="ph b">&lt;keydef keys="key-1" href="topic-1.dita"/&gt;</strong>
    &lt;topicref keyref="key-1"/&gt;
    &lt;topicref keyref="scope-1.key-1"/&gt;
    &lt;topicref keyref="scope-2.key-1"/&gt;
  &lt;/topicgroup&gt;

  &lt;!-- Key scope #2 --&gt;
  &lt;topicgroup keyscope="scope-2"&gt;
    <strong class="ph b">&lt;keydef keys="key-1" href="topic-2.dita"/&gt;</strong>
    &lt;topicref keyref="key-1"/&gt;
    &lt;topicref keyref="scope-1.key-1"/&gt;
    &lt;topicref keyref="scope-2.key-1" /&gt;
  &lt;/topicgroup&gt;

  &lt;topicref keyref="key-1" /&gt;
  &lt;topicref keyref="scope-1.key-1" /&gt;
  &lt;topicref keyref="scope-2.key-1" /&gt;

&lt;/map&gt;</code></pre>
  <p class="p">For this example, the effective key definitions are listed in the following tables.</p>
  <figure class="fig fignone"><figcaption><span class="fig--title-label">Figure 6. </span>Effective key definitions for scope-1</figcaption>
   
   <table class="simpletable frame-topbot"><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr class="sthead">
     <th class="stentry" scope="col" id="concept_zms_tw1_mp__stentry__1">Key reference</th>
     <th class="stentry" scope="col" id="concept_zms_tw1_mp__stentry__2">Resource</th>
    </tr></thead><tbody><tr class="strow">
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__1">key-1</td>
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__2"><span class="ph filepath">topic-1.dita</span></td>
    </tr><tr class="strow">
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__1">scope-1.key-1</td>
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__2"><span class="ph filepath">topic-1.dita</span></td>
    </tr><tr class="strow">
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__1">scope-2.key-1</td>
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__2"><span class="ph filepath">topic-2.dita</span></td>
    </tr></tbody></table>
  </figure>
  <figure class="fig fignone"><figcaption><span class="fig--title-label">Figure 7. </span>Effective key definitions for scope-2</figcaption>
   
   <table class="simpletable frame-topbot"><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr class="sthead">
     <th class="stentry" scope="col" id="concept_zms_tw1_mp__stentry__9">Key reference</th>
     <th class="stentry" scope="col" id="concept_zms_tw1_mp__stentry__10">Resource</th>
    </tr></thead><tbody><tr class="strow">
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__9">key-1</td>
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__10"><span class="ph filepath">topic-2.dita</span></td>
    </tr><tr class="strow">
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__9">scope-1.key-1</td>
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__10"><span class="ph filepath">topic-1.dita</span></td>
    </tr><tr class="strow">
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__9">scope-2.key-1</td>
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__10"><span class="ph filepath">topic-2.dita</span></td>
    </tr></tbody></table>
  </figure>
  <figure class="fig fignone"><figcaption><span class="fig--title-label">Figure 8. </span>Effective key definitions for the key scope associated with the root map</figcaption>
   
   <table class="simpletable frame-topbot"><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr class="sthead">
     <th class="stentry" scope="col" id="concept_zms_tw1_mp__stentry__17">Key reference</th>
     <th class="stentry" scope="col" id="concept_zms_tw1_mp__stentry__18">Resource</th>
    </tr></thead><tbody><tr class="strow">
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__17">key-1</td>
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__18">Undefined</td>
    </tr><tr class="strow">
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__17">scope-1.key-1</td>
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__18"><span class="ph filepath">topic-1.dita</span></td>
    </tr><tr class="strow">
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__17">scope-2.key-1</td>
     <td class="stentry" headers="concept_zms_tw1_mp__stentry__18"><span class="ph filepath">topic-2.dita</span></td>
    </tr></tbody></table>
  </figure>
 </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title29" lang="en-us" id="concept_myc_r2g_mp"> 
  <h4 class="title topictitle4" id="ariaid-title29">Example: Key definitions in nested key scopes</h4> 
   
  <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">In this scenario, the root map contains nested key scopes, each of
	 which contain duplicate key definitions. The effective key definition depends
	 on key-scope precedence rules. 
  </p> 
	 <p class="p">Consider the following DITA map: 
	 </p> 
	 <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;title&gt;Root map&lt;/title&gt;
  &lt;!-- Root scope --&gt;
  &lt;keydef keys="a" href="topic-1.dita"/&gt;
  
  &lt;!-- Key scope A --&gt;
  &lt;topicgroup keyscope="A"&gt;
    &lt;keydef keys="b" href="topic-2.dita"/&gt;
    
    &lt;!-- Key scope A-1 --&gt;
    &lt;topicgroup keyscope="A-1"&gt;
      &lt;keydef keys="c" href="topic-3.dita"/&gt;
    &lt;/topicgroup&gt;

    &lt;!-- Key scope A-2 --&gt;    
    &lt;topicgroup keyscope="A-2"&gt;
      &lt;keydef keys="d" href="topic-4.dita"/&gt;
    &lt;/topicgroup&gt;
  &lt;/topicgroup&gt; 

  &lt;!-- Key scope B --&gt;  
  &lt;topicgroup keyscope="B"&gt;
    &lt;keydef keys="a" href="topic-5.dita"/&gt;
    &lt;keydef keys="e" href="topic-6.dita"/&gt;

    &lt;!-- Key scope B-1 --&gt;     
    &lt;topicgroup keyscope="B-1"&gt;
      &lt;keydef keys="f" href="topic-7.dita"/&gt;
    &lt;/topicgroup&gt;

    &lt;!-- Key scope B-2 --&gt;
    &lt;topicgroup keyscope="B-2"&gt;
      &lt;keydef keys="g" href="topic-8.dita"/&gt;
    &lt;/topicgroup&gt;
  &lt;/topicgroup&gt;
&lt;/map&gt;</code></pre> 
	 <p class="p">The key scopes in this map form a tree structure. 
	 </p> 
	 <figure class="fig fignone"><figcaption><span class="fig--title-label">Figure 9. </span>Graphical representation of the key scopes</figcaption>
			
			<br><img class="image" src="images/Keyscopes-Illustrated.png" alt="Tree structure diagram showing example references to key scope names relative to other key scopes. The tree has a root node labeled 'Root' with two children 'A' and 'B', which in turn have children 'A-1', 'A-2', 'B-1', and 'B-2'. Every node has a list of one or more key scope names with different typographic styling. In the root node the name 'A' appears with no style, and the following labels appear with parentheses: 'A.b', 'A.A-1.c', 'A.A-2.d', 'B.a', 'B.e', 'B.B-1.f', 'B.B-2.g'. In the A node the name 'b' has no style, and the following labels appear with parentheses: 'A-1.c', 'A-2.d'. In the A-1 node the label 'c' appears with no style. In the A-2 node the label 'd' appears with no style. In the B node the label 'a' appears with square brackets; the label 'e' appears with no style; and the following labels appear with parentheses: 'B-1.f', 'B-2.g'. In the B-1 node the label 'f' appears with no style. In the B-2 node the label 'g' appears with no style."><br>
		</figure> 
	 <p class="p">Each box in the diagram represents a key scope; the name of the key
		scope is indicated in bold with upper-case letters. Below the name of the key
		scope, the key definitions that are present in the scope are listed. Different
		typographic conventions are used to indicate where the key definition occurs: 
	 </p> 
	 <dl class="dl"> 
		 
		  <dt class="dt dlterm">No styling 
		  </dt> 
		  <dd class="dd">The key definition occurs in the immediate key scope and is not
			 overridden by a key definition in a parent scope. For example, key "a" in the
			 root map. 
		  </dd> 
		 
		 
		  <dt class="dt dlterm">Parentheses 
		  </dt> 
		  <dd class="dd">The key definition occurs in a child scope. For example, keys
			 "A-1.c" and "A-2.d" in key scope A. 
		  </dd> 
		 
		 
		  <dt class="dt dlterm">Brackets 
		  </dt> 
		  <dd class="dd">The key definition occurs in the immediate key scope, but it is overridden by a key
					definition in an ancestor scope. For example, key "a" in key scope B. </dd> 
		 
	 </dl> 
	 <p class="p">Arrows point from child to parent scopes. 
	 </p> 
	 <p class="p">Assume that each key scope contains numerous key references. The following tables demonstrate
			how key references resolve in key scopes A-2 and B. The first column shows the value
			used in key references; the second column shows the resource to which the key resolves. </p>
    <figure class="fig fignone"><figcaption><span class="fig--title-label">Figure 10. </span>Key scope A-2</figcaption>
      
      <table class="simpletable frame-all"><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr class="sthead">
          <th class="stentry" scope="col" id="concept_myc_r2g_mp__stentry__1">Key reference </th>
          <th class="stentry" scope="col" id="concept_myc_r2g_mp__stentry__2">Resource to which the key resolves </th>
        </tr></thead><tbody><tr class="strow">
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__1">a </td>
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__2">"a", defined in the root map:
              <span class="ph filepath">topic-1.dita</span>
          </td>
        </tr><tr class="strow">
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__1">d </td>
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__2">"d", as defined in the immediate key scope:
              <span class="ph filepath">topic-4.dita</span>
          </td>
        </tr><tr class="strow">
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__1">A-2.d </td>
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__2">"d", as defined in the immediate key scope:
              <span class="ph filepath">topic-4.dita</span>
          </td>
        </tr><tr class="strow">
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__1">c </td>
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__2">Undefined </td>
        </tr><tr class="strow">
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__1">A-1.c </td>
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__2">"A-1.c", as defined in key scope A-1. This key name is
            available because it exists in the parent scope, key scope A.
            The key name resolves to <span class="ph filepath">topic-3.dita</span>
          </td>
        </tr><tr class="strow">
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__1">A.A-1.c </td>
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__2">"A-1.c", as defined in key scope A-1. This key name is
            available because it exists in the root key scope. The key name
            resolves to <span class="ph filepath">topic-3.dita</span>
          </td>
        </tr></tbody></table>
    </figure>
    <figure class="fig fignone"><figcaption><span class="fig--title-label">Figure 11. </span>Key scope B</figcaption>
      
      <table class="simpletable frame-topbot"><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr class="sthead">
          <th class="stentry" scope="col" id="concept_myc_r2g_mp__stentry__15">Key reference </th>
          <th class="stentry" scope="col" id="concept_myc_r2g_mp__stentry__16">Resource to which the key resolves </th>
        </tr></thead><tbody><tr class="strow">
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__15">e </td>
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__16">"e", defined in the immediate key scope:
              <span class="ph filepath">topic-6.dita</span>
          </td>
        </tr><tr class="strow">
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__15">a </td>
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__16">"a", as defined in the <em class="ph i">root key scope</em>. (While a
            key definition for "a" exists in the immediate key scope, it is
            overridden by the key definition that occurs in the parent key
            scope.) The key name resolves to
              <span class="ph filepath">topic-1.dita</span>
          </td>
        </tr><tr class="strow">
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__15">B.a </td>
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__16">
            <p class="p">"a", as defined in the <em class="ph i">immediate key scope</em>. Because
              the key reference uses the scope-qualified names, it resolves
              to the key "a" in scope B. The key name resolves to
                <span class="ph filepath">topic-5.dita</span>
            </p>
          </td>
        </tr><tr class="strow">
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__15">g </td>
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__16">Undefined. The key "g" is defined only in key scope B-2,
            so no unqualified key named "g" is defined in scope B.
          </td>
        </tr><tr class="strow">
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__15">B-2.g </td>
          <td class="stentry" headers="concept_myc_r2g_mp__stentry__16">"g", as defined in key scope B-2:
              <span class="ph filepath">topic-8.dita</span>. </td>
        </tr></tbody></table>
    </figure> 
  </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title30" lang="en-us" id="concept_bgq_np2_mp">
 <h4 class="title topictitle4" id="ariaid-title30">Example: Key scopes and omnibus publications</h4>
 
 <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">Key scopes enable you to create omnibus publications that include multiple submaps that
    define the same key names for common items, such as product names or common topic
    clusters.</p>
  <p class="p">In this scenario, a training organization wants to produce a deliverable that includes all of
   their training course materials. Each course manual uses common keys for standard parts of the
   course materials, including "prerequisites," "overview", "assessment", and "summary.</p>
  <p class="p">An information architect creates a root map that contains the following markup:</p>
  <pre class="pre codeblock"><code>&lt;map xml:lang="en"&gt;
  &lt;title&gt;Training courses&lt;/title&gt;
  &lt;mapref href="course-1.ditamap"/&gt;
  &lt;mapref href="course-2.ditamap"/&gt;
  &lt;mapref href="course-3.ditamap"/&gt;
  &lt;topicref href="omnibus-summary.dita"/&gt;
&lt;/map&gt;</code></pre>
  <p class="p">Each of the submaps contain <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> elements that refer to resources
      using the <code class="keyword markupname xmlatt">@keyref</code> attribute. Each submap uses common keys for standard parts
      of the course materials, including "prerequisites," "overview", "assessment", and "summary",
      and their key definitions bind the key names to course-specific resources. For example:</p>
  <pre class="pre codeblock"><code>&lt;map xml:lang="en"&gt;
  &lt;title&gt;Training course #1&lt;/title&gt;
  &lt;mapref href="course-1/key-definitions.ditamap"/&gt;
  &lt;topicref keyref="prerequisites"/&gt;
  &lt;topicref keyref="overview"/&gt;
  &lt;topicref keyref="assessment"/&gt;
  &lt;topicref keyref="summary"/&gt;
&lt;/map&gt;</code></pre>
  <p class="p">Without using key scopes, the effective key definitions for the common keys resolve to those
   found in <span class="ph filepath">course-1.ditamap</span>. This is not the desired outcome. By adding key
   scopes to the submaps, however, the information architect can ensure that the key references in
   the submaps resolve to the course-specific key definitions.</p>
  <pre class="pre codeblock"><code>&lt;map xml:lang="en"&gt;
  &lt;title&gt;Training courses&lt;/title&gt;
  &lt;mapref href="course-1.ditamap" <strong class="ph b">keyscope="course-1"</strong>/&gt;
  &lt;mapref href="course-2.ditamap" <strong class="ph b">keyscope="course-2"</strong>/&gt;
  &lt;mapref href="course-3.ditamap" <strong class="ph b">keyscope="course-3"</strong>/&gt;
  &lt;topicref href="omnibus-summary.dita"/&gt;
&lt;/map&gt;</code></pre>
  <p class="p">The information architect does <strong class="ph b">not</strong> set <code class="ph codeph">keys="summary"</code> on the
        <code class="keyword markupname xmlelement">&lt;topicref&gt;</code> element in the root map. Doing so would mean that all key
      references to "summary" in the submaps would resolve to
        <span class="ph filepath">omnibus-summary.dita</span>, rather than the course-specific summary topics.
      This is because key definitions located in parent scopes override those located in child
      scopes.</p>
 </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title31" lang="en-us" id="example-key-precedence-with-scopes">
  <h4 class="title topictitle4" id="ariaid-title31">Example: How key scopes affect key precedence</h4>
  
  <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc"><span class="ph">For purposes of key definition
          precedence, the scope-qualified key definitions from a child scope are considered to occur
          at the location of the scope-defining element within the parent scope.</span></p>
    <p class="p">Within a single key scope, key precedence is determined by which key definition comes first
      in the map, or by the depth of the submap that defines the key. This was true for all key
      definitions prior to DITA 1.3, because all key definitions were implicitly in the same key
      scope. Scope-qualified key names differ in that precedence is determined by the location where
      the key scope is defined.</p>
    <p class="p">This distinction is particularly important when key names or key scope names contain periods.
      While avoiding periods within these names will avoid this sort of issue, such names are legal
      so processors will need to handle them properly.</p>
    <p class="p">The following root map contains one submap and one key definition. The submap defines a key
      named "sample".</p>
    <figure class="fig fignone" id="example-key-precedence-with-scopes__fig_uqd_4rz_sr"><figcaption><span class="fig--title-label">Figure 12. </span>Root map</figcaption>
      
      <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;!-- The following mapref defines the key scope "scopeName" --&gt;
  &lt;mapref href="submap.ditamap" keyscope="scopeName"/&gt;

  &lt;!-- The following keydef defines the key "scopeName.sample" --&gt;
  &lt;keydef keys="scopeName.sample" href="losing-key.dita"/&gt;

  &lt;!-- Other content, key definitions, etc. --&gt;
&lt;/map&gt;</code></pre>
    </figure>
    <figure class="fig fignone"><figcaption><span class="fig--title-label">Figure 13. </span>Submap</figcaption>
      
      <pre class="pre codeblock"><code>&lt;map&gt;
  &lt;keydef keys="sample" href="winning-key.dita"/&gt;
  &lt;!-- Other content, key definitions, etc. --&gt;
&lt;/map&gt;</code></pre>
    </figure>
    <p class="p">When determining precedence, all keys from the key scope "scopeName" occur at the location of
      the scope-defining elementin this case, the <code class="keyword markupname xmlelement">&lt;mapref&gt;</code> element in the
      root map. Because the <code class="keyword markupname xmlelement">&lt;mapref&gt;</code> comes first in the root map, the
      scope-qualified key name "scopeName.sample" that is pulled from
        <span class="ph filepath">submap.ditamap</span> occurs before the definition of "scopeName.sample" in
      the root map. This means that in the context of the root map, the effective definition of
      "scopeName.sample" is the scope-qualified key definition that references
        <span class="ph filepath">winning-key.dita</span>.</p>
    <p class="p">The following illustration shows a root map and several submaps. Each submap defines a new
      key scope, and each map defines a key. In order to aid understanding, this sample does not use
      valid DITA markup; instead, it shows the content of submaps inline where they are
      referenced.</p>
    <figure class="fig fignone" id="example-key-precedence-with-scopes__fig_qxt_3lz_sr"><figcaption><span class="fig--title-label">Figure 14. </span>Complex map with multiple submaps and scopes</figcaption>
      
      <pre class="pre codeblock"><code>&lt;map&gt;   &lt;!-- Start of the root map --&gt;

  &lt;mapref href="submapA.ditamap" keyscope="scopeA"&gt;  
    &lt;!-- Contents of submapA.ditamap begin here --&gt;
    &lt;mapref href="submapB.ditamap" keyscope="scopeB"&gt;
      &lt;!-- Contents of submapB.ditamap: define key MYKEY --&gt;
      <strong class="ph b">&lt;keydef keys="MYKEY" href="example-ONE.dita"/&gt;</strong>
    &lt;/mapref&gt;
    <strong class="ph b">&lt;keydef keys="scopeB.MYKEY" href="example-TWO.dita"/&gt;</strong>
    &lt;!-- END contents of submapA.ditamap --&gt;
  &lt;/mapref&gt;

  &lt;mapref href="submapC.ditamap" keyscope="scopeA.scopeB"&gt;
    &lt;!-- Contents of submapC.ditamap begin here --&gt;
    <strong class="ph b">&lt;keydef keys="MYKEY" href="example-THREE.dita"/&gt;</strong>
  &lt;/mapref&gt;

  <strong class="ph b">&lt;keydef keys="scopeA.scopeB.MYKEY" href="example-FOUR.dita"/&gt;</strong>
&lt;/map&gt;</code></pre>
      
    </figure>
    <p class="p">The sample map shows four key definitions. <span class="ph">From the context of the
        root scope, all have key names of "scopeA.scopeB.MYKEY".</span></p>
    <ol class="ol">
      <li class="li"><span class="ph filepath">submapB.ditamap</span> defines the key "MYKEY". The key scope "scopeB" is
        defined on the <code class="keyword markupname xmlelement">&lt;mapref&gt;</code> to <span class="ph filepath">submapB.ditamap</span>, so
        from the context of <span class="ph filepath">submapA.ditamap</span>, the scope-qualified key name is
        "scopeB.MYKEY". The key scope "scopeA" is defined on the <code class="keyword markupname xmlelement">&lt;mapref&gt;</code> to
          <span class="ph filepath">submapA.ditamap</span>, so from the context of the root map, the
        scope-qualified key name is "scopeA.scopeB.MYKEY".</li>
      <li class="li"><span class="ph filepath">submapA.ditamap</span> defines the key "scopeB.MYKEY". The key scope
        "scopeA" is defined on the <code class="keyword markupname xmlelement">&lt;mapref&gt;</code> to
          <span class="ph filepath">submapA.ditamap</span>, so from the context of the root map, the
        scope-qualified key name is "scopeA.scopeB.MYKEY".</li>
      <li class="li"><span class="ph filepath">submapC.ditamap</span> defines the key "MYKEY". The key scope
        "scopeA.scopeB" is defined on the <code class="keyword markupname xmlelement">&lt;mapref&gt;</code> to
          <span class="ph filepath">submapC.ditamap</span>, so from the context of the root map, the
        scope-qualified key name is "scopeA.scopeB.MYKEY".</li>
      <li class="li">Finally, the root map defines the key "scopeA.scopeB.MYKEY".</li>
    </ol>
    <p class="p">Because scope-qualified key definitions are considered to occur at the location of the
      scope-defining element, the effective key definition is the one from
        <span class="ph filepath">submapB.ditamap</span> (the definition that references
        <span class="ph filepath">example-ONE.dita</span>).</p>
  </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title32" id="example_scoped_key_name_conflicts">
    <h4 class="title topictitle4" id="ariaid-title32">Example: How key scopes with the same name interact</h4>
    
    <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc">In a large publication it is possible that two sets of content will use the same key
        scope name. These scopes have no relationship with each other aside from the shared name;
        key definitions in one are not shared with the other.</p>
        <p class="p">This scenario is more likely in a large publication that pulls from multiple sources,
            where the root map refers to two sets of content that share a key scope name. Those key
            scopes are <a class="xref" href="Chunk563375964.html#keyscope-attribute__non-intersecting">non-intersecting</a>,
            meaning that key definitions within one scope are not automatically available to the
            other key scope that happens to share the same name.</p>
        <div class="p">In the following example, a root map refers to multiple product maps that are assembled
            into a custom product suite:<pre class="pre codeblock"><code>&lt;map&gt;
  &lt;title&gt;Custom product suite overview&lt;/title&gt;

  &lt;!-- Content from product A --&gt;
  &lt;mapref href="productA/productA.ditamap"/&gt;

  &lt;!-- Content from product B --&gt;
  &lt;mapref href="productB/productB.ditamap"/&gt;

  &lt;!-- ...Content from additional products... --&gt;
&lt;/map&gt;</code></pre></div>
        <div class="p">In this scenario, both product A and product B share a key scope name
                <span class="keyword">using</span>. The full context, showing content from both A and B, shows
          the shared key scope names and one shared key name:<pre class="pre codeblock"><code>&lt;map&gt;
  &lt;title&gt;Custom product suite overview&lt;/title&gt;

  &lt;!-- Content from product A (from productA.ditamap) --&gt;
  &lt;topicref href="productA/overview.dita"&gt;
    &lt;topicref href="productA/using.dita" keys="usingprodA" <strong class="ph b">keyscope="using"</strong>&gt;
      &lt;topicref href="productA/signup.dita" keys="signup"/&gt;
      &lt;topicref href="productA/logging-in.dita" keys="login"/&gt;
      &lt;!-- ... additional topics and keys --&gt;
      &lt;topicref href="productA/issues.dita" keys="troubleshooting"/&gt;
    &lt;/topicref&gt;
  &lt;/topicref&gt;

  &lt;!-- Content from product B (from productB.ditamap) --&gt;
  &lt;topicref href="productB/overview.dita"&gt;
    &lt;topicref href="productB/using.dita" keys="usingprodB" <strong class="ph b">keyscope="using"</strong>&gt;
      &lt;topicref href="productB/request-access.dita" keys="access"/&gt;
      &lt;topicref href="productB/log-in-to-portal.dita" keys="login-portal"/&gt;
      &lt;!-- ... additional topics and keys --&gt;
      &lt;topicref href="productB/troubleshooting.dita" keys="troubleshooting"/&gt;
    &lt;/topicref&gt;
  &lt;/topicref&gt;

  &lt;!-- ...Content from additional products... --&gt;
&lt;/map&gt;</code></pre></div>
        <div class="p">In the resolved view shown above, each product defines the key scope
                <span class="keyword">using</span>, and within that key scope each defines the key name
                <span class="keyword">troubleshooting</span>. Keys are resolved as follows:<ul class="ul" id="example_scoped_key_name_conflicts__ul_g5c_bqj_grb">
                <li class="li">Within the root map context:<ol class="ol" id="example_scoped_key_name_conflicts__ol_bfl_wqj_grb">
                        <li class="li">Keys unique to Product A's <span class="keyword">using</span> scope can be
                            referenced with that prefix: <span class="keyword">using.usingprodA</span>,
                                <span class="keyword">using.signup</span>, and
                            <span class="keyword">using.login</span>.</li>
                        <li class="li">Keys unique to Product B's <span class="keyword">using</span> scope can be
                            referenced with that prefix: <span class="keyword">using.usingprodB</span>,
                                <span class="keyword">using.access</span>, and
                                <span class="keyword">using.login-portal</span>.</li>
                        <li class="li">The scoped reference <span class="keyword">using.troubleshooting</span> is defined
                            twice. In this case, normal key precedence rules apply. It resolves to
                            the first definition, <span class="ph filepath">productA/issues.dita</span>.</li>
                        <li class="li">Product B's troubleshooting topic cannot be referenced by key because of
                            the conflict. The easiest way to make this key definition available
                            would be to add an additional scope around all of Product B's
                            content.</li>
                    </ol></li>
                <li class="li">Within the Product A context:<ol class="ol" id="example_scoped_key_name_conflicts__ol_qzh_lrj_grb">
                        <li class="li"><code class="ph codeph">keyref="usingprodA"</code> resolves to
                                <span class="ph filepath">productA/using.dita</span></li>
                        <li class="li"><code class="ph codeph">keyref="signup"</code> resolves to
                                <span class="ph filepath">productA/signup.dita</span></li>
                        <li class="li"><code class="ph codeph">keyref="login"</code> resolves to
                                <span class="ph filepath">productA/logging-in.dita</span></li>
                        <li class="li"><code class="ph codeph">keyref="troubleshooting"</code> resolves to
                                <span class="ph filepath">productA/issues.dita</span></li>
                        <li class="li">Keys that are in Product B's <span class="keyword">using</span> context, and are
                            unique to that context, can be referenced with the scope prefix:
                                <span class="keyword">using.usingprodB</span>,
                            <span class="keyword">using.access</span>,
                            <span class="keyword">using.login-portal</span></li>
                    </ol></li>
                <li class="li">Within the Product B context:<ol class="ol" id="example_scoped_key_name_conflicts__ol_hkj_3qj_grb">
                        <li class="li"><code class="ph codeph">keyref="usingprodB"</code> resolves to
                                <span class="ph filepath">productB/using.dita</span></li>
                        <li class="li"><code class="ph codeph">keyref="access"</code> resolves to
                                <span class="ph filepath">productB/request-access.dita</span></li>
                        <li class="li"><code class="ph codeph">keyref="login-portal"</code> resolves to
                                <span class="ph filepath">productB/log-in-to-portal.dita</span></li>
                        <li class="li"><code class="ph codeph">keyref="troubleshooting"</code> resolves to
                                <span class="ph filepath">productB/troubleshooting.dita</span></li>
                        <li class="li">Keys that are in Product A's <span class="keyword">using</span> context, and are
                            unique to that context, can be referenced with the scope prefix:
                                <span class="keyword">using.usingprodA</span>,
                            <span class="keyword">using.signup</span>, <span class="keyword">using.login</span></li>
                        <li class="li">The shared key definition <span class="keyword">using.troubleshooting</span>
                            resolves against the root context, which means it resolves to the
                            Product A context, <span class="ph filepath">productA/issues.dita</span></li>
                    </ol></li>
            </ul></div>
    </div>
</article><article class="topic concept nested3 non-normative" aria-labelledby="ariaid-title33" id="example-subjectrefs-attribute-with-key-scopes">
    <h4 class="title topictitle4" id="ariaid-title33">Example: <code class="keyword markupname xmlatt">@subjectrefs</code> attribute with key
    scopes</h4>
    
  <div class="body conbody"><p class="non-normative-label">This section is non-normative.</p><p class="shortdesc"></p>
    
    <p class="p">A subject scheme map may be included in a map as either a normal sub
      map or as a peer root map and associated with a key scope on the map
      reference.</p>
    <figure class="fig fignone"><figcaption><span class="fig--title-label">Figure 15. </span>A subject scheme map included as a sub map with a key scope: </figcaption>
      
      <pre class="pre codeblock"><code>&lt;map&gt;
 &lt;title&gt;User assistance for the Acme Widget&lt;/title&gt;
 &lt;!-- ... --&gt;
 &lt;mapref keyscope="subjects" href="subjectschemes/subject-scheme-01.ditamap"/&gt;
 &lt;topicref keyref="install-overview" subjectrefs="subjects.installing"&gt;
   &lt;topicref keyref="install-linux"/&gt;
   &lt;topicref keyref="install-macosx"/&gt;
   &lt;topicref keyref="install-windows"/&gt;
   &lt;topicref keyref="install-troubleshooting" subjectrefs="subjects.troubleshooting"/&gt;
 &lt;/topicref&gt;
 &lt;!-- ... --&gt; 
&lt;/map&gt;</code></pre>
    </figure>
    <p class="p"> The keys defined in referenced subject scheme map are included in
      the referencing map's key space. References to the subject keys must
      be scope qualified (i.e., "subjects.installing"). Putting the subject
      scheme keys in a key scope ensures that the keys defined in the
      subject scheme do not conflict with any keys defined elsewhere in the
      referencing map (although the referencing map could still override
      any keys defined in the subject scheme map).</p>
    <p class="p">The subject scheme map can also be referenced as a peer-scope root
      map in a key scope:</p>
    <pre class="pre codeblock"><code>&lt;map&gt;
 &lt;title&gt;User assistance for the Acme Widget&lt;/title&gt;
 &lt;!-- ... --&gt;
 &lt;mapref keyscope="subjects" scope="peer" href="subjectschemes/subject-scheme-01.ditamap"/&gt;
 &lt;topicref keyref="install-overview" subjectrefs="subjects.installing"&gt;
   &lt;topicref keyref="install-linux"/&gt;
   &lt;topicref keyref="install-macosx"/&gt;
   &lt;topicref keyref="install-windows"/&gt;
   &lt;topicref keyref="install-troubleshooting" subjectrefs="subjects.troubleshooting"/&gt;
 &lt;/topicref&gt;
 &lt;!-- ... --&gt; 
&lt;/map&gt;</code></pre>
    <p class="p">As a peer map, the keys defined in the subject scheme map are not
      included in the referencing map's key space but may be resolved using
      normal cross-deliverable key reference resolution. Processors that
      support cross-deliverable linking may also choose to resolve
      references from @"subjectrefs" to keys in peer subject scheme maps,
      for example to report keys specified on @"subjectrefs" that cannot be
      found in the peer subject scheme map.</p>
  </div>
</article></article></article></article><aside class="section-toc" role="aside"></aside></article></main>
